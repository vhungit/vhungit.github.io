[1,["f6SJZOjTJB/JrJeh5xTdF7","1brw/JvvpFnIvdrxpFCgMZ","baIUdvKGZPgZxNbjWTFuRI","d8JRMhBtNGsaZzIE3kp5XM@4e054","3292B0inpLVaUeyqucJ9WS@8a0df","3292B0inpLVaUeyqucJ9WS@69dc4","35c9A8y+lMl5mLK5cUGg8m","5earr9gO9E8rXxhMx+Sp8N@4ac0e","13HytXVdRMeYg0AkoRcobY@6c48a","28UavMG1hCpIoAreWg22BG@8a42b","b6p5zII7RJSoO+ey8c7+N4@6ddec","b6p5zII7RJSoO+ey8c7+N4@438fe","d8JRMhBtNGsaZzIE3kp5XM@b12cd","d8JRMhBtNGsaZzIE3kp5XM@fd0eb","d8JRMhBtNGsaZzIE3kp5XM@1834a","76NihQkqtDbLGJzkLWISsV@f9941","d3x4IMKphEKYvHuEU7yaxB","12Y9dMgWdJKJGmTiZyQR9H@a804a","28UavMG1hCpIoAreWg22BG@cce5b","b6p5zII7RJSoO+ey8c7+N4@db6a6","a82SVUPIBCZb+Ifce4X22W","e8qlCtcQFKZ5s8IXzJc4k9@23ca9","e8qlCtcQFKZ5s8IXzJc4k9@08c68","cb/B284PlAz7Kn2vLbwa4A@fd8a6","c4Cus9D1tEO7a+Bi7hdhUs@dc888","9e9KBCz2VD2ITp8KX5OZHi@b3a6d","0dDg2fPB5Fv7tMmxVhjRiX@ebfee","0dDg2fPB5Fv7tMmxVhjRiX@7c4c1","1dFphxiKBJ9qUTl6sqHFOA","58khY5jMJAHLaz6vVwvwsB@5c832","58khY5jMJAHLaz6vVwvwsB@ce9cf","7bFKBGS6JN0ZZn0lQsQ1ee@6ff48","28UavMG1hCpIoAreWg22BG@b75e9","28UavMG1hCpIoAreWg22BG@ff13c","7bFKBGS6JN0ZZn0lQsQ1ee@5c832","7bFKBGS6JN0ZZn0lQsQ1ee@d664e","3292B0inpLVaUeyqucJ9WS@ebfee","3292B0inpLVaUeyqucJ9WS@ecb24","3292B0inpLVaUeyqucJ9WS@0aa4c","3292B0inpLVaUeyqucJ9WS@d1274","3292B0inpLVaUeyqucJ9WS@a9e99","58khY5jMJAHLaz6vVwvwsB@be7d9","2fK4NeROxMMZ6i6xufiNZa","d8JRMhBtNGsaZzIE3kp5XM@74dce","d8JRMhBtNGsaZzIE3kp5XM@ee21d","d8JRMhBtNGsaZzIE3kp5XM@39fbe","d8JRMhBtNGsaZzIE3kp5XM@0efec","d8JRMhBtNGsaZzIE3kp5XM@2cd35","d8JRMhBtNGsaZzIE3kp5XM@34a56","d8JRMhBtNGsaZzIE3kp5XM@bf7a0","d8JRMhBtNGsaZzIE3kp5XM@dab9b","d8JRMhBtNGsaZzIE3kp5XM@bd178","d8JRMhBtNGsaZzIE3kp5XM@9f5aa","d8JRMhBtNGsaZzIE3kp5XM@11c07","d8JRMhBtNGsaZzIE3kp5XM@2b9d4","d8JRMhBtNGsaZzIE3kp5XM@de6db","f5ruMKUthGJZPTPHgBMIDT","c8LHt7j7hEdbreSxt1+dZ0","63WB8aHjxI2qxHxOGBmR5n","b9eD6q2udJsbm/FsRs0oS2","21pCL5UX1IPaHz57oZmzM7","4d9GSOUIxNJYVxMGIK5uoq","d7O+1T+g5Gp44ue09cBz1R","64a6gyvzxLqpTAaVzWTaQR","5fystUaRRC54TNlkbbPPgX","a5IiOwi6RFtayfJYTzIjg2","d0MqyYBeFAkIi762QNy1/B@b47c0","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","32TfsG4MFLmrXjPBzCCbpX","47QVy5yVhFkp3ELOlVYVLT","a4OBBCcbhNh49tThqM44tV","d8JRMhBtNGsaZzIE3kp5XM@494ce","d8JRMhBtNGsaZzIE3kp5XM@675ee","e8qlCtcQFKZ5s8IXzJc4k9@fbc79"],["node","_parent","_mesh","root","_effectAsset","data","targetInfo","_material","asset","mainTexture","clip","value","graph","target","source","_skeleton","_spriteFrame","_anyState","_exitState","_entryState","to","from","coinLabel","boxCollider","rigidBody","animationController","_cameraComponent","scene","grassPrefab","borderGrassPrefab","portPrefab","fieldPrefab","treePrefab","flowerPrefab","shopPrefab","_envmapHDR","_envmapLDR","tomatoContainer","cornContainer","fieldCellContainer","fieldCell","cornPlantS","cornPlantM","normalMap"],[["cc.Node",["_name","_layer","_id","_active","_objFlags","__editorExtras__","_prefab","_parent","_children","_components","_lrot","_euler","_lpos","_lscale"],-3,4,1,2,9,5,5,5,5],"cc.ImageAsset",["cc.Node",["_name","_layer","_parent","_children","_prefab","_lrot","_euler","_lpos","_lscale","_components"],1,1,9,4,5,5,5,5,2],["cc.BoxCollider",["_isTrigger","node","__prefab","_center","_size","_material"],2,1,4,5,5,6],["cc.Node",["_name","_layer","_parent","_prefab","_children","_lscale","_components","_lpos","_lrot","_euler"],1,1,4,12,5,12,5,5,5],["cc.PrefabInfo",["fileId","root","asset","nestedPrefabInstanceRoots","targetOverrides"],2,1,1,2,9],["cc.UITransform",["node","__prefab","_contentSize"],3,1,4,5],["cc.RigidBody",["_type","_mass","_useGravity","_group","node","__prefab","_linearFactor","_angularFactor"],-1,1,4,5,5],["cc.PrefabInstance",["fileId","propertyOverrides","prefabRootNode","mountedComponents","removedComponents"],2,9,1,9,9],["cc.Camera",["_visibility","_priority","_clearFlags","_projection","_orthoHeight","_far","node","_color"],-3,1,5],"cc.TextureCube",["cc.Material",["_states","_defines","_name","_props"],0,12],["cc.Material",["_name","_props","_defines","_states"],-1],["cc.Prefab",["_name"],2],["cc.MeshRenderer",["_name","node","__prefab","_materials","lightmapSettings","_mesh"],2,1,4,3,4,6],["cc.animation.AnimationController",["node","__prefab","graph"],3,1,4,6],["cc.animation.AnimationBlend1DItem",["threshold","motion"],2,4],["cc.TargetOverrideInfo",["propertyPath","source","target","targetInfo","sourceInfo"],2,1,1,4,4],["cc.Widget",["_alignFlags","_left","_right","_top","_bottom","_originalWidth","_originalHeight","node"],-4,1],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Node",["_name","_layer","_children","_components","_prefab","_lpos"],1,2,12,4,5],["cc.Node",["_name","_parent","_children","_components","_prefab","_lpos","_lrot","_lscale","_euler"],2,1,12,9,4,5,5,5,5],["cc.Node",["_name","_layer","_parent","_children","_components","_prefab","_lrot","_euler"],1,1,2,2,4,5,5],["cc.CompPrefabInfo",["fileId"],2],["cc.RenderRoot2D",["node","__prefab"],3,1,4],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.Label",["_string","_actualFontSize","_fontSize","_isBold","node","__prefab"],-1,1,4],["cc.Sprite",["node","__prefab","_spriteFrame"],3,1,4,6],["cc.ModelLightmapSettings",[],3],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,9],["cc.TargetInfo",["localID"],2],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,1],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["cc.animation.AnimationGraph",["_layers","_variables"],3,9,11],["cc.animation.Layer",["_stateMachine"],3,4],["cc.animation.StateMachine",["_states","_transitions","_entryState","_exitState","_anyState"],3,12,9,1,1,1],["cc.animation.Motion",["name","motion"],2,4],["cc.animation.ClipMotion",["clip"],3,6],["cc.animation.Transition",["from","to"],3,1,1],["cc.animation.PlainVariable",[],3],["cc.animation.TriggerVariable",[],3],["cc.animation.State",["name"],2],["cc.animation.AnimationBlend1D",["name","_items","param"],2,9,4],["cc.animation.BindableNumber",["variable"],2],["34f3cnK8S9LzKifP918l8es",["node","__prefab"],3,1,4],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.SkeletalAnimation",["node","__prefab"],3,1,4],["cc.SkinnedMeshRenderer",["_materials","node","__prefab","lightmapSettings","_skinningRoot","_mesh","_skeleton"],2,1,4,4,1,6,6],["cc.SkinnedMeshRenderer",["_shadowReceivingMode","node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],2,1,4,3,4,1,6,6],["beebfdGdkhMEp2H5VRBovmZ",["node","__prefab","animationController","rigidBody","boxCollider"],3,1,4,1,1,1],["cc.SceneAsset",["_name"],2],["cc.Scene",["_name","_children","_prefab","_globals"],2,12,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5,5],["cc.ShadowsInfo",["_enabled","_type","_shadowColor"],1,5],["cc.SkyboxInfo",["_enabled","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",[],3],["cc.OctreeInfo",[],3],["cc.Canvas",["node","_cameraComponent"],3,1,1],["ec17bSIBSFAPZG34QuGKdIZ",["node"],3,1],["c6076d9xaJIE69QP200khrJ",["node"],3,1],["b9686RX/fxPm5Y/3rgj053I",["node","target","followOffset"],3,1,1,5],["cc.DirectionalLight",["_shadowFixedArea","node","_staticSettings"],2,1,4],["cc.StaticLightSettings",[],3],["05ddbQ1ToRJKohgiz8rsa1h",["node","grassPrefab","borderGrassPrefab","portPrefab","fieldPrefab","treePrefab","flowerPrefab","shopPrefab"],3,1,6,6,6,6,6,6,6],["ed4fedB1QRFiouHJ3aoGu3k",["node","__prefab","fieldCellContainer","cornContainer","tomatoContainer","fieldCell","cornPlantS","cornPlantM"],3,1,4,1,1,1,6,6,6],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[5,0,1,2,2],[31,0,2],[23,0,2],[32,0,1,2,3],[28,1],[19,0,1,2,3],[14,1,2,3,4,5,1],[34,0,1,2,2],[33,0,1,2,2],[13,0,2],[11,2,0,1,3,4],[0,0,8,6,2],[0,0,7,8,6,12,10,11,2],[0,0,1,7,8,6,12,10,11,3],[0,4,5,7,6,3],[0,0,7,6,12,10,11,2],[0,0,1,7,6,12,10,11,3],[2,0,2,3,4,7,5,6,2],[2,0,1,2,3,4,7,5,6,3],[25,0,1,2,3,2],[37,0,1,2,3],[0,0,7,6,2],[0,0,7,9,6,12,13,2],[11,0,1,3,3],[7,0,4,5,2],[42,0,1],[0,0,7,9,6,2],[0,0,7,9,6,10,13,11,2],[0,0,7,8,6,12,10,13,11,2],[0,0,8,6,12,10,11,2],[0,0,1,8,6,12,10,11,3],[8,0,2,1,2],[13,1],[0,0,7,9,6,12,10,13,11,2],[0,0,7,8,6,12,13,2],[0,0,1,7,6,3],[6,0,1,2,1],[24,0,1,1],[3,1,2,3,4,5,1],[46,0,2],[16,0,1,2],[0,0,1,8,9,6,12,10,11,3],[0,0,1,7,9,6,12,13,3],[0,0,1,8,9,6,3],[0,0,7,6,12,10,13,11,2],[0,0,7,8,6,13,2],[0,0,8,9,6,2],[0,0,7,8,6,10,11,2],[0,0,7,6,13,2],[0,0,1,7,8,6,10,11,3],[0,0,2,7,9,12,10,11,3],[4,0,2,4,3,5,2],[4,0,2,4,3,2],[20,0,1,2,3,4,5,3],[6,0,2,1],[5,0,1,2,3,2],[5,0,1,2,4,3,2],[26,0,1,2,3,4,5,5],[41,0,1,2],[66,0,1,2,1],[12,0,1,2,4],[12,0,1,3,2,5],[0,0,1,7,9,6,13,3],[0,0,7,9,6,12,2],[0,0,7,8,6,10,13,11,2],[0,0,7,9,6,13,2],[0,0,1,8,9,6,10,11,3],[0,0,7,9,6,10,11,2],[0,0,3,8,6,3],[0,0,7,8,6,2],[0,0,7,6,12,13,2],[0,0,3,7,8,9,6,12,13,3],[0,0,1,7,9,6,10,11,3],[0,0,1,7,8,6,12,10,13,11,3],[0,0,2,7,3],[0,0,1,2,7,8,9,12,4],[0,0,1,7,8,9,3],[0,0,2,7,9,10,11,3],[0,0,2,7,9,3],[4,0,1,2,6,3,5,3],[4,0,2,4,3,7,8,9,2],[2,0,2,3,4,5,6,2],[2,0,2,3,4,8,2],[2,0,2,9,7,2],[21,0,1,2,3,4,5,6,7,8,2],[22,0,1,2,3,4,5,6,7,3],[6,0,1,1],[5,0,3,2],[27,0,1,2,1],[3,1,2,4,5,1],[3,1,2,3,5,1],[3,1,2,3,4,1],[3,0,1,2,3,4,5,2],[7,0,1,2,4,5,6,7,4],[7,3,1,2,4,5,6,7,4],[14,0,1,2,3,4,5,2],[8,0,2,3,1,4,2],[8,0,1,2],[29,0,1,2,3],[30,0,1,1],[15,0,1,2,1],[15,0,1,1],[35,0,1,2,2],[36,0,1,2,2],[38,0,1,1],[39,0,1],[40,0,1,2,3,4,1],[43,0,1,1],[44,1],[45,1],[47,0,1,2,2],[16,1,1],[48,0,2],[17,0,1,2,3,2],[17,0,1,4,2,3,2],[49,0,1,1],[50,0,1,2,3,4],[51,0,1,1],[52,0,1,2,3,4,5,6,2],[53,0,1,2,3,4,5,6,7,2],[54,0,1,2,3,4,1],[55,0,2],[56,0,1,2,3,2],[57,0,1,2,3,4,1],[58,0,1,2,3,4,2],[59,0,1,2,3],[60,0,1,2,2],[61,1],[62,1],[63,0,1,1],[18,0,1,2,3,4,7,6],[18,0,5,6,7,4],[64,0,1],[65,0,1],[9,1,2,0,6,7,4],[9,0,6,7,2],[9,3,1,4,5,2,0,6,7,7],[67,0,1,2,2],[68,1],[69,0,1,2,3,4,5,6,7,1],[70,0,1,2,3,4,5,6,7,1],[71,0,1,2,4]],[[[[5,".bin",24300421,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":10920,"length":2160,"count":540,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":10920,"count":195,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.0022114517632871866,-0.0009727145079523325,-0.002952176844701171],"maxPosition",8,[1,0.0029032963793724775,0.008849951438605785,0.002959541277959943]]],-1],0,0,[],[],[]],[[[10,"Plant",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":20},"mainColor",8,[4,4282759540],"specularColor",8,[4,4281545523],"emissiveColor",8,[4,4278190080]]],11]]],0,0,[0],[4],[0]],[[[5,".bin",3434579268,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]],-1],0,0,[],[],[]],[[[9,"coinUnlockMap"],[41,"coinUnlockMap",8388608,[-4,-5],[[86,-2,[2,"95n6Ia96xCjL2luvNHQoIP"]],[37,-3,[2,"55aS2u0dZCcZSM6qHPqc+Q"]]],[0,"7ehJcuY7hEuJnUxJ3ad3bX",-1,0],[1,4.731,0,-2.531],[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001],[1,-90,-90,0]],[62,"Label",8388608,1,[[36,-6,[2,"9eIzKWzcRKCIgXtTgWJzn5"],[5,55.62,50.4]],[57,"10",50,50,true,-7,[2,"5fxcHDooBITLY0DHua3m5G"]],[37,-8,[2,"74Iln7N3ZFspKBrXdN0bXC"]]],[0,"e31uJnJnRJFJEAXit28y7a",1,0],[1,0.005,0.005,0]],[42,"icon_coin",8388608,1,[[36,-9,[2,"25Nuyz5ShClaxoIGGyBAT7"],[5,77,82]],[88,-10,[2,"acA7FRAbBIGIxPtOQv0wQk"],0]],[0,"019ejOGoBGobRjSNJ+JewA",1,0],[1,0,-0.403,0],[1,0.005,0.005,1]]],0,[0,3,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,0,2,0,0,2,0,0,2,0,0,3,0,0,3,0,5,1,10],[0],[16],[15]],[[[9,"border"],[43,"border",16,[-4],[[38,-2,[2,"86RY3fwZFLiow1oZ/t7nLw"],[1,0,0,0.5],[1,1,2,0.1],2],[24,2,-3,[2,"f8UC6NnFpCk6Jk2WJVNGsd"]]],[0,"71Mio6DppDYq0x3DZhyEQI",-1,0]],[42,"fakeModelToEasyView",16,1,[[95,"Cube<ModelComponent>",-5,[2,"57z3h+ITxA54ilPlYvXGEc"],[0],[4],1]],[0,"cbC5psKylJ6oHt1mM18mok",1,0],[1,0,-0.5,0.5],[1,1,1,0.1]]],0,[0,3,1,0,0,1,0,0,1,0,-1,2,0,0,2,0,5,1,5],[0,0,0],[-1,2,7],[16,17,2]],[[[10,"Mat_Nature",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true,"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":0.078125},"mainColor",8,[4,4294967295],"specularColor",8,[4,4281545523],"emissiveColor",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[9,4],[18,0]],[[[5,".bin",2407890921,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":26496,"length":8400,"count":2100,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":26496,"count":552,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0002515930973459035,-0.0002883222477976233,0.0004593447083607316],"maxPosition",8,[1,0.0002884231216739863,0.0002744296798482537,0.0009167310781776905]]],-1],0,0,[],[],[]],[[[5,".bin",1035890256,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":9792,"length":3648,"count":912,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":9792,"count":204,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.00010488595580682158,-0.00008979292761068791,-0.0000024813693926262204],"maxPosition",8,[1,0.00012069090007571504,0.000044811116822529584,0.0003191498981323093]]],-1],0,0,[],[],[]],[[[9,"businessMan"],[41,"businessMan",64,[-5],[[93,2,400,false,-3,[2,"07b3299yJJ5Ly6kjmfRGbs"],[1,1,0,1],[1,0,0,0]],[38,-4,[2,"9cTiJEoT5F9ZBrBN8CG2gf"],[1,0,0.9,0],[1,0.4,1.8,1],3]],[55,"27Tz8E9N5CmINb8qOCZMHh",-2,0,[-1]],[1,2.404,0,0.835],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,0,-90,0]],[14,0,null,1,[19,"b7CaxeemBbJ6YBFDMYG/8T",-10,[96,"f4N3rsbLxHlarLZ4gG0hLi",1,[[99,[1,["b7CaxeemBbJ6YBFDMYG/8T"]],[[100,-9,[2,"517hTmy9xM1LbeaBoyh1oN"],1]]]],[[3,"Stickman_heads_sphere",["_name"],[1,["b7CaxeemBbJ6YBFDMYG/8T"]]],[8,["_lpos"],[1,["b7CaxeemBbJ6YBFDMYG/8T"]],[1,0,0,0]],[8,["_lscale"],[1,["b7CaxeemBbJ6YBFDMYG/8T"]],[1,1,1,1]],[8,["_lrot"],[1,["b7CaxeemBbJ6YBFDMYG/8T"]],[3,0,-0.70710676908493,0,0.7071067932881648]],[7,["_euler"],-6,[1,0,-89.99999803884896,0]],[102,["_materials","0"],[1,["9f1GdkxJBR7awiMcnkbimg"]],2],[103,["_skinningRoot"],[1,["9f1GdkxJBR7awiMcnkbimg"]],-7],[3,0,["_shadowCastingMode"],[1,["9f1GdkxJBR7awiMcnkbimg"]]],[3,false,["lightmapSettings","_castShadow"],[1,["9f1GdkxJBR7awiMcnkbimg"]]],[3,false,["lightmapSettings","_receiveShadow"],[1,["9f1GdkxJBR7awiMcnkbimg"]]],[3,0,["_shadowReceivingMode"],[1,["9f1GdkxJBR7awiMcnkbimg"]]],[20,1073741824,["_layer"],-8],[3,1073741824,["_layer"],[1,["bauJ7U+w1VBJ3HjZN0u+3Y"]]],[3,1073741824,["_layer"],[1,["a7nyQryZdd17TUoFldZevH"]]],[3,1073741824,["_layer"],[1,["f91ed4lg1S3Kcie0CQWYzT"]]],[3,1073741824,["_layer"],[1,["93mT8hnVtecK3DOCeCTGbx"]]],[3,1073741824,["_layer"],[1,["d2lrYrl5RTXI5iL+22iHYx"]]],[3,1073741824,["_layer"],[1,["66at3YryBbG5+SudHNiOyP"]]],[3,1073741824,["_layer"],[1,["10UuyJylZYGLUZaJsPEpCR"]]],[3,1073741824,["_layer"],[1,["27Vrv9vTdSTqq0XBihpu2h"]]],[3,1073741824,["_layer"],[1,["91XDTtMDZRoaIabLdak6cT"]]],[3,1073741824,["_layer"],[1,["812pKp8KVURbrmAuwFgcXv"]]],[3,1073741824,["_layer"],[1,["7cZ1ettqNdEYYl8zvtmASc"]]],[3,1073741824,["_layer"],[1,["76uT536PpQmLrylyP0AZvJ"]]],[3,1073741824,["_layer"],[1,["ce9cKRawpXy5Q4mUb4qymN"]]],[3,1073741824,["_layer"],[1,["d60YqYzdtT07HWW206BdE4"]]],[3,1073741824,["_layer"],[1,["aca0YJd+Ba1JI3tAMOpTbn"]]],[3,1073741824,["_layer"],[1,["5dIaT7w0tWl7sqIGnnoqQ0"]]],[3,1073741824,["_layer"],[1,["03HIPlQqNV/65yCHyrdZRe"]]],[3,1073741824,["_layer"],[1,["absGwNCUdX+IZgb2kjfyyc"]]],[3,1073741824,["_layer"],[1,["63yDZZW8JcxrZWNI9miEyM"]]],[3,1073741824,["_layer"],[1,["e0ENB1KEtaFYmhrQu6umgp"]]],[3,1073741824,["_layer"],[1,["a5GyBx+o9fMalFUWRcp2gs"]]],[3,1073741824,["_layer"],[1,["a4Of731rhZ75fnIQWA00AD"]]],[3,1073741824,["_layer"],[1,["2f9t+/pOhSc7+TpNvGh76N"]]],[3,1073741824,["_layer"],[1,["19R719wbVaYp/FxPyvBG0y"]]],[3,1073741824,["_layer"],[1,["27Zm7KTxZd4KsceVtIYG2R"]]],[3,1073741824,["_layer"],[1,["a9WCV9sRZSOob5k0OGZCBz"]]],[3,1073741824,["_layer"],[1,["7eQ3QKQZdapao/hgdc3twd"]]],[3,1073741824,["_layer"],[1,["3d1tHDrMhaR4IvOnAeC01n"]]],[3,1073741824,["_layer"],[1,["70/duAuCtfNY79tm6zwx8k"]]],[3,1073741824,["_layer"],[1,["fb8wEj/mZUkYW5zMTTk1h/"]]],[3,1073741824,["_layer"],[1,["bfEPGx/otbd7RzkaCRbsK6"]]]],[[1,["c0R9+LEYxbBaGMsfd8y1Kd"]]]],0]],[1,["b7CaxeemBbJ6YBFDMYG/8T"]]],0,[0,-1,2,0,3,1,0,0,1,0,0,1,0,-1,2,0,6,3,0,11,2,0,6,3,0,0,2,0,3,2,0,5,1,10],[0,0,0,0],[8,12,11,7],[19,6,20,2]],[[[9,"fieldCell"],[11,"fieldCell",[-2],[0,"fckkr65exElIn803QRXAQb",-1,0]],[51,"FieldCell",1,[[-3,[21,"CropMover",-4,[0,"3bF3+I+mFLKK1n+29ahsyw",1,0]],-5],1,4,1],[0,"18iO2Jn35EHq018NU6k80p",1,0],[1,50,50,50]],[52,"PlantRoot",2,[[[44,"DustSystem",-6,[0,"ddvg0ha1RDKa7RtmgF0rlM",1,0],[1,0,0.0020000000949949026,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,0.30000001192092896,0.20000000298023224,0.30000001192092896],[1,-90.00000000000003,0,0]],-7],4,1],[0,"b4ElbeM81Lxqr/g8+t3IhU",1,0]],[81,"FX_Seed",3,[[21,"Cone",-8,[0,"18Btxzz85AyLmA6G/NCGsL",1,0]],[21,"Stars",-9,[0,"edBANwTlZB8L3DlRNuY2Pn",1,0]]],[0,"21xUJP+S9Ef6DrL04V2NEj",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[63,"Plane",2,[[6,-10,[2,"1bytVuC2lNdqGDtUfqYxKZ"],[0],[4],1]],[0,"44VgBGg3ZEvodtFpZjw8Wa",1,0],[1,0,0.0003499999875202775,0]]],0,[0,3,1,0,-1,2,0,-1,5,0,1,2,0,-3,3,0,1,3,0,-2,4,0,1,4,0,1,4,0,0,5,0,5,1,10],[0,0],[-1,2],[21,22]],[[[5,".bin",2834530542,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16128,"length":2688,"count":672,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":40544,"length":3600,"count":900,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":16128,"count":288,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":18816,"length":21728,"count":388,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.0014745102962478995,-0.0003302526893094182,-0.0017936642980203032],"maxPosition",8,[1,0.001724712084978819,0.008272114209830761,0.0020397845655679703]]],-1],0,0,[],[],[]],[[[10,"PlantDark",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":20},"mainColor",8,[4,4279929159],"specularColor",8,[4,4281545523],"emissiveColor",8,[4,4278190080]]],11]]],0,0,[0],[4],[0]],[[[10,"CornYellow",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":20},"mainColor",8,[4,4278243839],"specularColor",8,[4,4281545523],"emissiveColor",8,[4,4278195353]]],11]]],0,0,[0],[4],[0]],[[[5,".bin",2834530542,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16128,"length":2688,"count":672,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":40544,"length":3600,"count":900,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":16128,"count":288,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":18816,"length":21728,"count":388,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.0014745102962478995,-0.0003302526893094182,-0.0017936642980203032],"maxPosition",8,[1,0.001724712084978819,0.008272114209830761,0.0020397845655679703]]],-1],0,0,[],[],[]],[[[5,".bin",2834530542,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16128,"length":2688,"count":672,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":40544,"length":3600,"count":900,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":16128,"count":288,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":18816,"length":21728,"count":388,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.0014745102962478995,-0.0003302526893094182,-0.0017936642980203032],"maxPosition",8,[1,0.001724712084978819,0.008272114209830761,0.0020397845655679703]]],-1],0,0,[],[],[]],[[[10,"Plant",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":20},"mainColor",8,[4,4282759540],"specularColor",8,[4,4281545523],"emissiveColor",8,[4,4278190080]]],11]]],0,0,[0],[4],[0]],[[[5,".bin",24300421,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":10920,"length":2160,"count":540,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":10920,"count":195,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.0022114517632871866,-0.0009727145079523325,-0.002952176844701171],"maxPosition",8,[1,0.0029032963793724775,0.008849951438605785,0.002959541277959943]]],-1],0,0,[],[],[]],[[[104,[[105,[106,[[-6,-7,-8,-9,[58,"Harvesting",[25,4]]],1,1,1,1,4],[[107,-5,-4]],-3,-2,-1]]],[{},"MoveSpeed",4,[108],"IsHarvesting",4,[109]]],[39,"Entry"],[39,"Exit"],[39,"Any"],[58,"Movement",[110,"Movement",[[111,[25,0]],[40,1,[25,1]],[40,2,[25,2]],[40,6,[25,3]]],[112,"MoveSpeed"]]]],0,[0,17,3,0,18,2,0,19,1,0,20,4,0,21,1,0,-1,1,0,-2,2,0,-3,3,0,-4,4,9],[0,0,0,0,0],[10,10,10,10,10],[23,24,25,7,7]],[[[9,"cornPlantS"],[11,"cornPlantS",[-2],[0,"be4JsKA5BQSa/jzcQfU0mY",-1,0]],[45,"CornPlant_S",1,[-3],[0,"95jTKyuQRewZAg/VsJL0Ls",1,0],[1,50,50,50]],[26,"VisualRoot",2,[[6,-4,[2,"93pPDv2FhaxJ3PQw9ibhco"],[0],[4],1]],[0,"5clRZrqcBfuoizEoYr8VfP",1,0]]],0,[0,3,1,0,-1,2,0,-1,3,0,0,3,0,5,1,4],[0,0],[-1,2],[26,27]],[[[9,"port"],[53,"port",4,[-8],[[[89,-5,[2,"3cqIu2FUtCwIi9yjVE+pK6"],[1,1,1,5],1],[24,2,-6,[2,"a2Cd8nUYlKzLwlSmVZ2kuU"]],-7],4,4,1],[56,"9bREgHp/1NN57KLtPN3HxK",-4,0,[[113,["coinLabel"],-3,-2,[1,["5fxcHDooBITLY0DHua3m5G"]]]],[-1]],[1,2,0,5]],[14,0,{},1,[19,"7ehJcuY7hEuJnUxJ3ad3bX",-11,[31,"fcEcEC4p5Bq4zQdPJ3El+P",1,[[3,"coinUnlockMap",["_name"],[1,["7ehJcuY7hEuJnUxJ3ad3bX"]]],[8,["_lpos"],[1,["7ehJcuY7hEuJnUxJ3ad3bX"]],[1,0.5,0,0]],[8,["_lscale"],[1,["7ehJcuY7hEuJnUxJ3ad3bX"]],[1,1,1,1]],[8,["_lrot"],[1,["7ehJcuY7hEuJnUxJ3ad3bX"]],[3,-0.5000000000000001,-0.5000000000000001,-0.4999999999999999,0.5000000000000002]],[7,["_euler"],-9,[1,-89.99999999999999,-89.99999999999999,0]],[20,8388608,["_layer"],-10],[3,8388608,["_layer"],[1,["e31uJnJnRJFJEAXit28y7a"]]],[3,8388608,["_layer"],[1,["019ejOGoBGobRjSNJ+JewA"]]]]],0]],[79,"Label",8388608,2,[[[36,-12,[2,"9eIzKWzcRKCIgXtTgWJzn5"],[5,55.62,50.4]],-13,[37,-14,[2,"74Iln7N3ZFspKBrXdN0bXC"]]],4,1,4],[0,"e31uJnJnRJFJEAXit28y7a",1,0],[1,0.005,0.005,0]],[1,["7ehJcuY7hEuJnUxJ3ad3bX"]],[115,1,[2,"11dhdnvFRAdroABTzVZJvr"]],[57,"10",50,50,true,3,[2,"5fxcHDooBITLY0DHua3m5G"]]],0,[0,-1,2,0,13,2,0,14,5,0,3,1,0,0,1,0,0,1,0,-3,5,0,-1,2,0,6,4,0,6,4,0,3,2,0,0,3,0,-2,6,0,0,3,0,5,1,5,22,6,14],[0,0],[8,7],[28,2]],[[[23,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":1},"mainColor",8,[4,4291611852],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[9,4],[8,1]],[[[32],[11,"Fruit_Cart_Shop",[-2],[0,"3f03fAs3JTDaYhRpvbeyNU",-1,0]],[26,"Fruit_Cart_Shop",1,[[6,-3,[2,"387wWEt/Vburq8udhD51FV"],[0],[4],1]],[0,"4f0izYuR1diK/cVBEuQRIU",1,0]]],0,[0,3,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,2],[29,30]],[[[5,".bin",212666655,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":76560,"length":10416,"count":2604,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":76560,"count":1595,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.3620868921279907,-0.003168582683429122,-0.8343105912208557],"maxPosition",8,[1,1.3620868921279907,2.28743577003479,0.9004103541374207]]],-1],0,0,[],[],[]],[[[9,"flowerYellow"],[1,["231cF9z7RYtoOeGXZKRfbp"]],[11,"flowerYellow",[-3],[55,"c3cTpva/pN+ZkeJLJn7p4P",-2,0,[-1]]],[14,0,null,2,[19,"231cF9z7RYtoOeGXZKRfbp",-4,[31,"724/o98eRCYb3miCBnazgb",2,[[20,"Flowers_Yellow",["_name"],1],[7,["_lpos"],1,[1,0,0,0]],[7,["_lscale"],1,[1,0.5,0.5,0.5]],[7,["_lrot"],1,[3,0,1,0,6.123233995736766e-17]],[7,["_euler"],1,[1,0,180,0]]]],0]]],0,[0,-1,3,0,3,2,0,-1,3,0,3,3,0,5,2,4],[0],[8],[31]],[[[9,"tree"],[11,"tree",[-2],[0,"d806vfHtNGu5L9ZfQRvaSf",-1,0]],[11,"TreeRoot",[-3,-4],[0,"b9P0la/xBGD71ZDoMTgVML",1,0]],[45,"tree",1,[2],[0,"35t+phQQlBv5pHkFQeMc4i",1,0],[1,35,35,35]],[33,"Tree_Top_D_01_LOD0",2,[[6,-5,[2,"9aDEEModBDs5m1D/FxBo2B"],[0],[4],1]],[0,"57wjYN9sVBYpfsqyUjzaXb",1,0],[1,0,-0.002899999963119626,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,58.85307312011719,63.55284881591797,49.671016693115234],[1,-90.00000965934633,0,0]],[27,"Shrub_Btm_A_03_LOD0",2,[[6,-6,[2,"09iHbJsMVNt7Ey5deYxQX+"],[2],[4],3]],[0,"501ZlGLnNOBr6kleQyV+I+",1,0],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,75.77499389648438,45.1089973449707,92.83099365234375],[1,-90.00000965934633,0,0]]],0,[0,3,1,0,-1,3,0,-1,4,0,-2,5,0,0,4,0,0,5,0,5,1,2,1,3,6],[0,0,0,0],[-1,2,-1,2],[9,32,9,33]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@e9a6d","back":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@40c10","left":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@8fd34","right":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@74afd","top":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@bb97f","bottom":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@7d38f"}]}],[10],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[23,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":1},"mainColor",8,[4,4291611852],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[9,4],[8,1]],[[[32],[11,"Flowers_Yellow",[-2],[0,"231cF9z7RYtoOeGXZKRfbp",-1,0]],[26,"Flowers_Yellow",1,[[6,-3,[2,"4a56LV0otZz7L1k8QmQDGg"],[0],[4],1]],[0,"35MEDEfZpTk7xfINIFl48T",1,0]]],0,[0,3,1,0,-1,2,0,0,2,0,5,1,3],[0,0],[-1,2],[34,35]],[[[5,".bin",2917607531,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":26496,"length":4896,"count":1224,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":26496,"count":552,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.4783105254173279,-0.1514364629983902,-0.42992502450942993],"maxPosition",8,[1,0.476426362991333,0.7954724431037903,0.3880831301212311]]],-1],0,0,[],[],[]],[[[9,"cornPlantM"],[11,"cornPlantM",[-2],[0,"2b/k1l4HBem4O5hKa17mf8",-1,0]],[11,"VisualRoot",[-3,-4,-5,-6],[0,"197KxVJ4VeiKs7wnqze506",1,0]],[64,"CornPlant_M",1,[2],[0,"f3h/T3AuxVe44ZUyJO9RWx",1,0],[3,0,-0.4350739378834819,0,0.9003947293129608],[1,50,50,50],[1,0,-51.57999750657414,0]],[65,"CornPlant_Grown (1)",2,[[6,-7,[2,"2cUlTqVQBUeIxAwFNPVUIo"],[0],[4],1]],[0,"35F6xtgp5QzYdq3YUYnIZI",1,0],[1,2,2,2]],[28,"CornRoot",2,[-8],[0,"d3alA/+t5ddrVV8+kdt/OG",1,0],[1,0,0.01307000033557415,0],[3,-0.05417085850372388,0.0022638731332916256,-0.15803213530944418,0.9859443377680828],[1,0.75,0.75,0.75],[1,-6.4117644689169575,-0.7633043996617473,-18.17178366624208]],[34,"Corn",5,[-9],[0,"fdFtyaORpU+q1uJJ0MA1V7",1,0],[1,0.000590000010561198,0.0002800000074785203,-0.0005200000014156103],[1,0.800000011920929,0.800000011920929,0.800000011920929]],[27,"VisualRoot",6,[[6,-10,[2,"a39AGK/NlVqYVI9TI1OoH0"],[2,3],[4],4]],[0,"5c21AdQcpYxpffY+0sHbKt",1,0],[3,-0.2065863489810603,-0.09885047517351268,0.2724273243716268,0.9345234169930482],[1,2,2,2],[1,-23.44353067579039,-4.959265325725324,33.368504822986395]],[28,"CornRoot (1)",2,[-11],[0,"cetWEa6cFfFI0ktn71+EvY",1,0],[1,0.0005699999746866524,0.008669999428093433,0.00014999999257270247],[3,-0.21709023082976592,0.9191232182632162,0.2063831357286486,0.25591080988218795],[1,0.75,0.75,0.75],[1,-30.869251692818736,144.13884924638018,-17.063656435674705]],[34,"Corn",8,[-12],[0,"076Shq/ZRR87BptSfF733q",1,0],[1,0.000590000010561198,0.0002800000074785203,-0.0005200000014156103],[1,0.800000011920929,0.800000011920929,0.800000011920929]],[27,"VisualRoot",9,[[6,-13,[2,"55D/rQypVQkbz0pl1h9PAx"],[5,6],[4],7]],[0,"d3MdxsgJZd4q3Tv4bKShQG",1,0],[3,-0.2065863489810603,-0.09885047517351268,0.2724273243716268,0.9345234169930482],[1,2,2,2],[1,-23.44353067579039,-4.959265325725324,33.368504822986395]],[28,"CornRoot (2)",2,[-14],[0,"40eBXxi3haXbfR7ptoNp5+",1,0],[1,0.00011000000085914508,0.005960000213235617,0.00013000000035390258],[3,-0.28660029211077404,0.23063749105660777,-0.08707854163326122,0.9257882845813921],[1,0.75,0.75,0.75],[1,-30.869301788779303,23.234511708247144,-17.0636648009929]],[34,"Corn",11,[-15],[0,"57+vaa5GVRMbmRByhScuGw",1,0],[1,0.000590000010561198,0.0002800000074785203,-0.0005200000014156103],[1,0.800000011920929,0.800000011920929,0.800000011920929]],[27,"VisualRoot",12,[[6,-16,[2,"a0Pe1HSwFXyq23tFvBujj5"],[8,9],[4],10]],[0,"d2gXpxPk9RxbKWkVdchr/g",1,0],[3,-0.2065863489810603,-0.09885047517351268,0.2724273243716268,0.9345234169930482],[1,2,2,2],[1,-23.44353067579039,-4.959265325725324,33.368504822986395]]],0,[0,3,1,0,-1,3,0,-1,4,0,-2,5,0,-3,8,0,-4,11,0,0,4,0,-1,6,0,-1,7,0,0,7,0,-1,9,0,-1,10,0,0,10,0,-1,12,0,-1,13,0,0,13,0,5,1,2,1,3,16],[0,0,0,0,0,0,0,0,0,0,0],[-1,2,-1,-2,2,-1,-2,2,-1,-2,2],[36,37,4,5,38,4,5,39,4,5,40]],[[[9,"shop"],[66,"shop",8,[-8,-9],[[38,-6,[2,"2dXFAz6dxBtYNnGj+0K5HY"],[1,0,0.5,0],[1,1.25,1,1],2],[24,2,-7,[2,"4f3saEf39NWaqzr0ENcspk"]]],[56,"ceSpKcJZlKLoNnP5EZplle",-5,0,[[114,["_skinningRoot"],-4,[1,["f4N3rsbLxHlarLZ4gG0hLi","9f1GdkxJBR7awiMcnkbimg"]],-3,[1,["f4N3rsbLxHlarLZ4gG0hLi","b7CaxeemBbJ6YBFDMYG/8T"]]]],[-1,-2]],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,0,-90,0]],[1,["3f03fAs3JTDaYhRpvbeyNU"]],[14,0,{},1,[19,"27Tz8E9N5CmINb8qOCZMHh",-12,[31,"cdRP/5jv9GY4XQ0+Up6iTC",1,[[3,"businessMan",["_name"],[1,["27Tz8E9N5CmINb8qOCZMHh"]]],[8,["_lpos"],[1,["27Tz8E9N5CmINb8qOCZMHh"]],[1,-1.129,0,0.835]],[8,["_lscale"],[1,["27Tz8E9N5CmINb8qOCZMHh"]],[1,0.5,0.5,0.5]],[8,["_lrot"],[1,["27Tz8E9N5CmINb8qOCZMHh"]],[3,0,-0.7071067811865475,0,0.7071067811865476]],[8,["_euler"],[1,["27Tz8E9N5CmINb8qOCZMHh"]],[1,0,-90,0]],[7,["_size"],-10,[1,2,1.8,2]],[20,true,["_isTrigger"],-11]]],1]],[14,0,null,1,[19,"3f03fAs3JTDaYhRpvbeyNU",-13,[31,"80YcNTkE5F7ov2cJ31Emwq",1,[[20,"Fruit_Cart_Shop",["_name"],2],[7,["_lpos"],2,[1,0,0,0]],[7,["_lscale"],2,[1,1,1,1]],[7,["_lrot"],2,[3,0,0,0,1]],[7,["_euler"],2,[1,0,0,0]],[8,["_lscale"],[1,["4f0izYuR1diK/cVBEuQRIU"]],[1,0.5,0.5,0.5]]]],0]],[1,["9cTiJEoT5F9ZBrBN8CG2gf"]]],0,[0,-1,3,0,-2,4,0,13,3,0,14,3,0,3,1,0,0,1,0,0,1,0,-1,4,0,-2,3,0,6,5,0,6,5,0,3,3,0,3,4,0,5,1,13],[0,0,0],[8,8,7],[41,42,2]],[[[10,"BusinessMan",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_BATCHING":true},{},{}],[[[{},"mainColor",8,[4,4278234623]],{},{}],11,0,0]]],0,0,[0],[4],[1]],[[[116,"Skin-0",3872059137,["Skelet.c/root","Skelet.c/root/pelvis","Skelet.c/root/pelvis/spine_01","Skelet.c/root/pelvis/spine_01/spine_02","Skelet.c/root/pelvis/spine_01/spine_02/spine_03","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_l","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_l/upperarm_l","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_l/upperarm_l/lowerarm_l","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_l/upperarm_l/lowerarm_l/hand_l","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_l/upperarm_l/lowerarm_l/hand_l/index_01_l","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_l/upperarm_l/lowerarm_l/hand_l/index_01_l/index_02_l","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_l/upperarm_l/lowerarm_l/hand_l/thumb_01_l","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_l/upperarm_l/lowerarm_l/hand_l/thumb_01_l/thumb_02_l","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_r","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_r/upperarm_r","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_r/upperarm_r/lowerarm_r","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_r/upperarm_r/lowerarm_r/hand_r","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_r/upperarm_r/lowerarm_r/hand_r/index_01_r","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_r/upperarm_r/lowerarm_r/hand_r/index_01_r/index_02_r","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_r/upperarm_r/lowerarm_r/hand_r/thumb_01_r","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/clavicle_r/upperarm_r/lowerarm_r/hand_r/thumb_01_r/thumb_02_r","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/neck_01","Skelet.c/root/pelvis/spine_01/spine_02/spine_03/neck_01/head","Skelet.c/root/pelvis/thigh_l","Skelet.c/root/pelvis/thigh_l/calf_l","Skelet.c/root/pelvis/thigh_l/calf_l/foot_l","Skelet.c/root/pelvis/thigh_r","Skelet.c/root/pelvis/thigh_r/calf_r","Skelet.c/root/pelvis/thigh_r/calf_r/foot_r"],[[[7,-1,2.4492886759122114e-16,0.000004116688614885788,0,2.44929873442846e-16,1,2.449283646654087e-16,0,-0.000004116688614885788,2.4492937051703357e-16,-1,0,0,0,0,1],[7,-2.583961133950652e-7,-8.72209469093832e-8,-1,0,0.002653694013133645,0.999996542930603,-8.79063364322974e-8,0,0.9999964833259583,-0.0026536942459642887,-2.581637374987622e-7,0,-0.011816463433206081,-0.5320144295692444,-0.00035301499883644283,1],[7,-2.8714580935229606e-7,-8.513157467859855e-8,-1,0,0.09168875217437744,0.9957877993583679,-1.111010092813558e-7,0,0.9957876801490784,-0.09168875962495804,-2.7813067049464735e-7,0,-0.06137404963374138,-0.6024429798126221,-0.0003530021640472114,1],[7,-2.5929833213922393e-7,-6.841293753723221e-8,-1,0,-0.06674408912658691,0.997770369052887,-5.095373367680622e-8,0,0.9977700114250183,0.0667441114783287,-2.6328632429795107e-7,0,0.036828577518463135,-0.741450846195221,-0.0003530413086991757,1],[7,0.000050597296649357304,0.0011046375147998333,-0.9999994039535522,0,-0.027597596868872643,0.9996187686920166,0.001102820155210793,0,0.9996190667152405,0.02759753167629242,0.00008106333552859724,0,0.0030803175177425146,-0.8613673448562622,-0.0013044339139014482,1],[7,0.3821814954280853,-0.9058327078819275,0.1827685534954071,0,-0.013409269042313099,-0.2031981199979782,-0.9790459871292114,0,0.92399001121521,0.37172240018844604,-0.08980514109134674,0,0.010102634318172932,0.2155573070049286,1.1523462533950806,1],[7,-0.01708163693547249,-0.8178243637084961,0.5752147436141968,0,0.03273475170135498,-0.5754475593566895,-0.8171836137771606,0,0.9993181824684143,0.004870677832514048,0.03660086542367935,0,-0.1058274433016777,0.5386670827865601,1.0160715579986572,1],[7,-0.23147737979888916,-0.6425685286521912,0.7304273843765259,0,-0.4078468084335327,-0.6175552606582642,-0.6725226640701294,0,0.8832210898399353,-0.45357614755630493,-0.11911943554878235,0,0.26148179173469543,0.41073861718177795,0.939164936542511,1],[7,0.43058472871780396,-0.8825474977493286,0.1889621466398239,0,-0.9022652506828308,-0.42617157101631165,0.0655410960316658,0,0.022687170654535294,-0.19871491193771362,-0.9797947406768799,0,0.9954267740249634,-0.06584253162145615,0.013050554320216179,1],[7,0.4926697611808777,-0.7438766360282898,0.4515790641307831,0,-0.7621244192123413,-0.6193164587020874,-0.18871498107910156,0,0.4200512170791626,-0.25118520855903625,-0.8720451593399048,0,0.9121139645576477,0.10565535724163055,0.37337663769721985,1],[7,0.7542606592178345,-0.3084631860256195,0.57960444688797,0,-0.3557223379611969,-0.9339681267738342,-0.034139152616262436,0,0.5518624782562256,-0.18042846024036407,-0.814182698726654,0,0.7452619075775146,0.5584513545036316,0.3267833888530731,1],[7,-0.5592058300971985,-0.1310432255268097,0.8186063170433044,0,-0.6566253304481506,-0.5327814221382141,-0.5338416695594788,0,0.5060945153236389,-0.8360452055931091,0.21188820898532867,0,0.31332188844680786,0.3148133158683777,0.8824712634086609,1],[7,-0.7264968156814575,-0.16909155249595642,0.6660407185554504,0,-0.2654927968978882,-0.8249205350875854,-0.4990188479423523,0,0.63381028175354,-0.539364755153656,0.5544096231460571,0,-0.08274882286787033,0.5406366586685181,0.8122287392616272,1],[7,0.38218143582344055,0.9058328866958618,-0.18276874721050262,0,0.013409236446022987,-0.2031983584165573,-0.9790460467338562,0,-0.9239899516105652,0.37172240018844604,-0.08980517089366913,0,-0.010102619417011738,0.21555757522583008,1.1523462533950806,1],[7,-0.017081614583730698,0.8178256750106812,-0.5752127766609192,0,-0.032734934240579605,-0.575445830821991,-0.8171846866607666,0,-0.9993180632591248,0.004870717879384756,0.03660101071000099,0,0.10582759976387024,0.5386648774147034,1.016072392463684,1],[7,-0.23147714138031006,0.6425687074661255,-0.7304274439811707,0,0.40784645080566406,-0.6175556182861328,-0.6725226044654846,0,-0.8832212686538696,-0.45357587933540344,-0.1191193163394928,0,-0.26148152351379395,0.4107387959957123,0.9391646981239319,1],[7,0.43058478832244873,0.882547914981842,-0.18896229565143585,0,0.9022653102874756,-0.42617183923721313,0.06554103642702103,0,-0.022687291726469994,-0.19871510565280914,-0.9797948002815247,0,-0.9954268336296082,-0.06584253162145615,0.013050702400505543,1],[7,0.4926696717739105,0.7438774704933167,-0.45157915353775024,0,0.7621247172355652,-0.619316816329956,-0.1887151002883911,0,-0.42005130648612976,-0.25118544697761536,-0.8720453381538391,0,-0.9121140241622925,0.10565528273582458,0.3733767867088318,1],[7,0.7542605996131897,0.30846405029296875,-0.5796046257019043,0,0.355723112821579,-0.9339682459831238,-0.03413964435458183,0,-0.5518628358840942,-0.18042859435081482,-0.8141827583312988,0,-0.7452625036239624,0.5584510564804077,0.3267838656902313,1],[7,-0.5592060685157776,0.13104361295700073,-0.8186067342758179,0,0.6566257476806641,-0.5327817797660828,-0.5338419079780579,0,-0.5060953497886658,-0.8360453248023987,0.21188808977603912,0,-0.3133222162723541,0.31481337547302246,0.8824715614318848,1],[7,-0.7264969348907471,0.16909223794937134,-0.6660411953926086,0,0.26549264788627625,-0.8249208331108093,-0.49901914596557617,0,-0.6338112354278564,-0.5393646955490112,0.5544095039367676,0,0.08274891972541809,0.5406364798545837,0.8122292160987854,1],[7,-3.8660800782963634e-8,-7.170430649239279e-8,-1,0,0.148441344499588,0.9889213442802429,-7.664876733315396e-8,0,0.9889212250709534,-0.1484413594007492,-2.7588606954509487e-8,0,-0.20669199526309967,-1.1759212017059326,5.586332463280996e-8,1],[7,2.686578284283314e-7,-4.850732704397842e-9,-1,0,-0.0025864241179078817,0.9999967217445374,-5.545579107035792e-9,0,0.9999966025352478,0.0025864243507385254,2.6864441338148026e-7,0,-0.016923222690820694,-1.2702627182006836,-4.043994650260174e-8,1],[7,0.11737561225891113,-0.15915541350841522,0.9802515506744385,0,-0.2235523909330368,-0.9659743309020996,-0.13006921112537384,0,0.9675992131233215,-0.2038704752922058,-0.1489613801240921,0,0.13641026616096497,0.5583805441856384,0.1776636242866516,1],[7,0.05814690142869949,-0.0487227700650692,0.9971187114715576,0,0.2307797074317932,-0.9710978865623474,-0.0609092116355896,0,0.9712674021720886,0.23365631699562073,-0.045222096145153046,0,-0.004816307686269283,0.28874874114990234,0.16577889025211334,1],[7,0.014894058927893639,-0.019921423867344856,-0.9996907114982605,0,0.9998475909233093,-0.008828805759549141,0.015072330832481384,0,-0.009126332588493824,-0.9997631311416626,0.019786877557635307,0,-0.005220911931246519,0.00984223559498787,-0.16579733788967133,1],[7,0.11737740784883499,0.1591513305902481,-0.9802529215812683,0,0.22355370223522186,-0.965974748134613,-0.13006477057933807,0,-0.9676001071929932,-0.20387190580368042,-0.1489623636007309,0,-0.13641121983528137,0.558381199836731,0.17766112089157104,1],[7,0.05814889073371887,0.048729367554187775,-0.9971187710762024,0,-0.2307804375886917,-0.9710974097251892,-0.06091612949967384,0,-0.9712689518928528,0.2336570918560028,-0.045222386717796326,0,0.004816130269318819,0.2887475788593292,0.16578087210655212,1],[7,0.014894360676407814,0.01991981826722622,0.9996914267539978,0,-0.9998474717140198,-0.008829607628285885,0.01507264468818903,0,0.009127099066972733,-0.9997649788856506,0.019785234704613686,0,0.005220880266278982,0.009842516854405403,-0.1657973974943161,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[5,".bin",2130955239,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":86040,"length":22512,"count":5628,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":86040,"count":1195,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]]},"minPosition",8,[1,-0.6138684749603271,-0.0051850080490112305,-0.30234676599502563],"maxPosition",8,[1,0.6138684749603271,1.8435494899749756,0.29083508253097534]]],-1],0,0,[],[],[]],[[[32],[46,"Stickman_heads_sphere",[-3,-4],[[117,-2,[2,"c0R9+LEYxbBaGMsfd8y1Kd"]]],[0,"b7CaxeemBbJ6YBFDMYG/8T",-1,0]],[29,"pelvis",[-5,-6,-7],[0,"93mT8hnVtecK3DOCeCTGbx",1,0],[1,0.0003530216054059565,0.5320438146591187,-0.010404620319604874],[3,0.000938245192798024,0.7071074700741742,0.0009381609081067217,0.707104847469857],[1,0.000006547519907902562,90.00021249711088,0.15204235717723355]],[29,"spine_03",[-8,-9,-10],[0,"7cZ1ettqNdEYYl8zvtmASc",1,0],[1,1.9732389056059674e-9,0.11913514882326126,-2.084243888589299e-11],[3,-0.0005527358210240716,0.000014614251237330086,0.019595084915175535,0.9998078449965787],[1,-0.06340821012290593,0.002917718983056647,2.2455737799618842]],[29,"hand_l",[-11,-12],[0,"a4Of731rhZ75fnIQWA00AD",1,0],[1,4.284083843231201e-8,0.19866184890270233,4.330649971961975e-8],[3,-0.1913259893245287,-0.5592927844419798,0.019054326859227904,0.8063639871100823],[1,-17.232663223271103,-67.33283971812196,14.166701685863258]],[29,"hand_r",[-13,-14],[0,"2f9t+/pOhSc7+TpNvGh76N",1,0],[1,-2.0489096641540527e-8,0.19866184890270233,3.259629011154175e-8],[3,-0.1913251247384335,0.5592929027194505,-0.019054548482251094,0.8063641049759169],[1,-17.23256153789166,67.33286123332685,-14.166668597063124]],[67,"Stickman_heads_sphere",1,[[118,[null],-15,[2,"9f1GdkxJBR7awiMcnkbimg"],[4],1,0,1]],[0,"bauJ7U+w1VBJ3HjZN0u+3Y",1,0],[3,6.123234262925839e-17,1,6.123234262925839e-17,3.7493993930529855e-33],[1,-7.0167096047110005e-15,-180,7.0167096047110005e-15]],[47,"Skelet.c",1,[-16],[0,"a7nyQryZdd17TUoFldZevH",1,0],[3,-0.7071067215818986,3.090861663997002e-8,-3.09086237453975e-8,0.7071068407911901],[1,-89.9999903406537,-1.5351845413740977e-13,-0.000005008956312487746]],[47,"root",7,[2],[0,"f91ed4lg1S3Kcie0CQWYzT",1,0],[3,0.7071068407896928,-0.000001455469739434805,-0.000001455469398374286,0.7071067215804012],[1,90.00000965934632,-7.753346216819752e-12,-0.00023586894010005214]],[12,"spine_01",2,[-17],[0,"d2lrYrl5RTXI5iL+22iHYx",1,0],[1,-0.004331294912844896,0.07350046932697296,1.3029043399725992e-9],[3,1.0946637331541135e-8,-1.051213512125179e-8,0.04456724581582408,0.9990063866664676],[1,0.0000013120437142162198,-0.0000012643323844857656,5.108722323184987]],[12,"spine_02",9,[3],[0,"27Vrv9vTdSTqq0XBihpu2h",1,0],[1,0.019369743764400482,0.13551770150661469,-5.630812260903895e-9],[3,-3.3986080420356614e-8,-1.8928189179573522e-8,-0.07922262859740593,0.9968569481716602],[1,-0.000004105647938027835,-0.000002502135270211383,-9.087767625861655]],[12,"clavicle_l",3,[-18],[0,"d60YqYzdtT07HWW206BdE4",1,0],[1,-0.015249783173203468,0.31068751215934753,0.01920408010482788],[3,0.7585752595210817,0.1284185795083252,-0.14661160089817354,0.6217533936872901],[1,101.17918472442217,22.466995717382073,0.7172354816536206]],[12,"upperarm_l",11,[-19],[0,"03HIPlQqNV/65yCHyrdZRe",1,0],[1,2.7939677238464355e-9,0.1396692395210266,-6.51925802230835e-9],[3,0.21380619586668112,0.059386342435993084,0.1648129066665299,0.9610394782407343],[1,24.615091314252783,2.6637595113666532,20.009610369179782]],[12,"lowerarm_l",12,[4],[0,"e0ENB1KEtaFYmhrQu6umgp",1,0],[1,3.725290298461914e-9,0.26387739181518555,1.5087425708770752e-7],[3,0.08541884987519217,-0.10010077023140458,0.2310170373923381,0.9640096391216978],[1,13.49933867152886,-14.907122727126435,25.35999584338928]],[17,"index_01_l",4,[[15,"index_02_l",-20,[0,"3d1tHDrMhaR4IvOnAeC01n",1,0],[1,3.166496753692627e-8,0.05361089110374451,4.842877388000488e-8],[3,0.10384132745600216,0.01118666775302738,-0.25023230988668327,0.9625360399826771],[1,13.542216467723723,4.804474864852943,-28.645697258656362]]],[0,"19R719wbVaYp/FxPyvBG0y",1,0],[1,0.012653877027332783,0.062184080481529236,-0.004037775099277496],[3,0.05375861150786414,0.18280420206457337,-0.109233643117032,0.9755822090463017],[1,8.488907336687232,22.05652890382414,-11.155837825617352]],[17,"thumb_01_l",4,[[15,"thumb_02_l",-21,[0,"70/duAuCtfNY79tm6zwx8k",1,0],[1,-5.587935447692871e-7,0.028589412569999695,-2.7939677238464355e-8],[3,0.1221369380461655,0.14330084909884125,-0.16966328365820074,0.9673478201715117],[1,17.33903761962359,19.471756928808784,-17.052159565010502]]],[0,"27Zm7KTxZd4KsceVtIYG2R",1,0],[1,0.013693361543118954,0.03710309788584709,0.053495854139328],[3,0.48533847647419237,0.5553387371377874,0.10012528987449876,0.6678475698956049],[1,46.54524462239025,60.60344930383616,42.28287185663701]],[12,"clavicle_r",3,[-22],[0,"aca0YJd+Ba1JI3tAMOpTbn",1,0],[1,-0.015247837640345097,0.3107299506664276,-0.019225364550948143],[3,-0.1467915644126778,-0.6225846493548879,0.7578804594901887,-0.12828795784433644],[1,101.06217958612535,157.52581149194737,-0.6688588236483445]],[12,"upperarm_r",16,[-23],[0,"absGwNCUdX+IZgb2kjfyyc",1,0],[1,-5.587935447692871e-9,0.13966920971870422,6.05359673500061e-9],[3,0.21380619643428858,-0.059386297890167035,-0.16481290710407118,0.9610394807920785],[1,24.61509226596958,-2.6637542626492836,-20.009609314348115]],[12,"lowerarm_r",17,[5],[0,"a5GyBx+o9fMalFUWRcp2gs",1,0],[1,-1.862645149230957e-9,0.2638774812221527,-1.1641532182693481e-9],[3,0.08541834503337176,0.10010085429444764,-0.23101635680074403,0.9640098382235488],[1,13.499262890161257,14.90710397472364,-25.359923973239773]],[17,"index_01_r",5,[[15,"index_02_r",-24,[0,"fb8wEj/mZUkYW5zMTTk1h/",1,0],[1,-1.4901161193847656e-8,0.053610909730196,-4.842877388000488e-8],[3,0.1038411940374416,-0.01118685502340313,0.25023210293771453,0.9625361060006699],[1,13.542202676787952,-4.804490187762133,28.645671061681373]]],[0,"a9WCV9sRZSOob5k0OGZCBz",1,0],[1,-0.012653809040784836,0.06218409910798073,-0.004037774167954922],[3,0.05375876595353191,-0.18280416540513766,0.10923342295276645,0.9755822320561739],[1,8.488919230469095,-22.056523335206258,11.155809964799012]],[17,"thumb_01_r",5,[[15,"thumb_02_r",-25,[0,"bfEPGx/otbd7RzkaCRbsK6",1,0],[1,6.034970283508301e-7,0.02858944982290268,-2.7939677238464355e-8],[3,0.12213705151709808,-0.1433010509823956,0.1696632905880798,0.9673477747226565],[1,17.33905464996592,-19.47178293880197,17.05215453980309]]],[0,"7eQ3QKQZdapao/hgdc3twd",1,0],[1,-0.013693323358893394,0.03710305690765381,0.0534958653151989],[3,0.4853378864523561,-0.5553386248220414,-0.10012553698653778,0.6678480550229081],[1,46.545155475613214,-60.60344930047373,-42.282845747655394]],[17,"neck_01",3,[[15,"head",-26,[0,"63yDZZW8JcxrZWNI9miEyM",1,0],[1,0.0018450785428285599,0.07722138613462448,-3.212807797581263e-11],[3,1.307798659220679e-8,1.7502537594571004e-7,-0.07571666629030933,0.9971293729731621],[1,0.000003047877995634063,0.000020345610519282447,-8.684802702391597]]],[0,"5dIaT7w0tWl7sqIGnnoqQ0",1,0],[1,-0.00002404675069556106,0.33257636427879333,0.00001432070985174505],[3,0.0005479554532572181,-0.00007392619595385615,0.08818183099526028,0.9961042410119848],[1,0.06429337426889734,-0.014196126356094081,10.11802924153785]],[12,"thigh_l",2,[-27],[0,"66at3YryBbG5+SudHNiOyP",1,0],[1,-0.0019309008494019508,0.060946110635995865,0.10094382613897324],[3,0.9891818493566049,-0.10959382058002042,-0.06462320510132841,0.07302263181064483],[1,172.31252245684405,6.593244657754153,-13.0766493723749]],[17,"calf_l",22,[[15,"foot_l",-28,[0,"76uT536PpQmLrylyP0AZvJ",1,0],[1,0.00006084551569074392,0.29228517413139343,-0.00028398275026120245],[3,0.7823355397381153,-0.6219819346706755,-0.03257073917585142,0.005359398803419615],[1,-171.91605627859073,11.178270494156601,-76.79181311103764]]],[0,"91XDTtMDZRoaIabLdak6cT",1,0],[1,9.313225746154785e-9,0.3119881749153137,-2.7939677238464355e-9],[3,0.03465793283187069,0.052570458522714136,-0.22374995061810693,0.9726104740238654],[1,5.7861597045155095,7.50175547328921,-25.569087461636848]],[28,"thigh_r",2,[-29],[0,"10UuyJylZYGLUZaJsPEpCR",1,0],[1,-0.0019309690687805414,0.06094609573483467,-0.1016499325633049],[3,-0.06462356335475432,-0.07302261761635526,0.9891816205134767,0.10959568428602379],[1,0.9999980330467224,0.9999997615814209,0.9999986886978149],[1,172.31253826482302,173.40672523557967,13.076866270297616]],[17,"calf_r",24,[[15,"foot_r",-30,[0,"ce9cKRawpXy5Q4mUb4qymN",1,0],[1,-0.00006084900815039873,0.29228517413139343,-0.00028399628354236484],[3,0.7823184547213856,0.6223313664131324,0.0256584932665719,-0.0048111853005443185],[1,-170.0674035966481,-11.633198291641099,76.77413772639794]]],[0,"812pKp8KVURbrmAuwFgcXv",1,0],[1,-1.862645149230957e-8,0.31198829412460327,-8.381903171539307e-9],[3,0.03465776453059902,-0.05257035320860371,0.22375267324889345,0.9726098593656338],[1,5.786166889643856,-7.501765667782016,25.56940796807284]]],0,[0,3,1,0,0,1,0,-1,6,0,-2,7,0,-1,9,0,-2,22,0,-3,24,0,-1,11,0,-2,16,0,-3,21,0,-1,14,0,-2,15,0,-1,19,0,-2,20,0,0,6,0,-1,8,0,-1,10,0,-1,12,0,-1,13,0,1,14,0,1,15,0,-1,17,0,-1,18,0,1,19,0,1,20,0,1,21,0,-1,23,0,1,23,0,-1,25,0,1,25,0,5,1,2,1,8,3,1,10,4,1,13,5,1,18,30],[0,0],[2,15],[10,11]],[[[9,"Parcel"],[46,"Parcel",[-4],[[90,-2,[2,"a8VqdNnFBLXIBfUttBUnpJ"],[1,0,-0.5,0],24],[24,2,-3,[2,"ceUqcOka9M278r635KNPhK"]]],[0,"66mTnCtqZC27enez4oe4mH",-1,0]],[51,"Parcel",1,[[-5,[21,"Bound",-6,[0,"52BTWhEHtDB6IygKPLeigg",1,0]],-7,-8,[44,"MinimapPOI",-9,[0,"71B42Da8dNuaHBJc1W0hQZ",1,0],[1,0,-0.08460000157356262,0],[3,0.7071067811865476,0,0,0.7071067811865476],[1,0.5914015173912048,0.5914013385772705,0.5914013385772705],[1,90.00000000000003,0,0]]],1,4,1,1,4],[0,"2et4dlB75DLI/NrLHQbpqU",1,0],[1,16.75,16.75,16.75]],[68,"Roads",false,[-10,-11,-12,-13,-14],[0,"7bqB+V1KpJX6I6s4RWKwLd",1,0]],[52,"VisualUnscaled",2,[[[21,"Assets",-15,[0,"cce4PkE2hErIINsTcmHCGP",1,0]],-16,3],4,1,1],[0,"08bJUKU/NIL7OWtyFRHnJs",1,0]],[69,"Ground",4,[-17,-18,-19],[0,"5aBcPwMeVAOY23BPUDeRxn",1,0]],[84,"MiniMapCell",2,[[-21,[70,"Sprite",-22,[0,"71tdwCG65PTJxSK8OX9T2e",1,0],[1,0,0,-0.0002099999983329326],[1,0.28567999601364136,0.28567999601364136,0.28567999601364136]]],1,4],[[6,-20,[2,"376EFZeKhMbKqRAg7aggHp"],[22],[4],23]],[0,"a2f+LCJIFJ1pLnVWS955gY",1,0],[1,0,-0.09000000357627869,0],[3,0.7071067811865476,0,0,0.7071067811865476],[1,6,6,6],[1,90.00000000000003,0,0]],[71,"Sand",false,5,[-24],[[6,-23,[2,"3cihYGQ1BDuIxyhGyVQ9x4"],[2],[4],3]],[0,"19llazUplAeLI+ioPdreE8",1,0],[1,0,-0.02500000037252903,0],[1,7.5,4,7.5]],[80,"LockedSprite",2,[[[48,"BGSprite",-25,[0,"fc5kgLbqFFSr0Kki35GLlh",1,0],[1,1.708734393119812,1.708734393119812,1.708734393119812]],-26],4,1],[0,"4eQe74COhOmp3xRI04C5wK",1,0],[1,0,0.00019999999494757503,0],[3,0.7071067811865476,0,0,0.7071067811865476],[1,90.00000000000003,0,0]],[82,"LockedCanvas",8,[[21,"Text",-27,[0,"08dAiLwZJClZd6JNwjyxMq",1,0]],[48,"Image",-28,[0,"090W4Qq85LyqU2fOibwCGz",1,0],[1,0.9300000071525574,0.9300000071525574,0.9300000071525574]]],[0,"444P3ZIetIg75/arcW61Mv",1,0],[1,0.8977912068367004,0.8977912068367004,0.8977912068367004]],[22,"Ground",7,[[6,-29,[2,"15c3ClJYlH05mYWKnwaKZ7"],[0],[4],1]],[0,"77wZeeqCxN/I0CFJuiTrqk",1,0],[1,0,0.0054709999822080135,0],[1,0.8000000715255737,0.13331818580627441,0.8000000715255737]],[22,"Grass",5,[[6,-30,[2,"8eZ/BjtspPSZS/FcONbqjT"],[4],[4],5]],[0,"1f776JyxNCNboNKK5OtKWP",1,0],[1,0,-0.0001999974192585796,0],[1,6,0.04999999701976776,6]],[26,"Mesh",5,[[6,-31,[2,"8bDzQSxw1GlbfmdL/pVRRV"],[6,7,8],[4],9]],[0,"e5IUTsJe1J56VngcGws6fN",1,0]],[33,"Road_End",3,[[6,-32,[2,"69sd/FV1hOSJn5fBQZYukP"],[10],[4],11]],[0,"b2pvWbPR1B6pGwDC9CoSM2",1,0],[1,0,0.00009999999747378752,0],[3,0,0.7071067811865476,0,0.7071067811865476],[1,1,0.5,1],[1,0,90.00000000000003,0]],[22,"Road_I",3,[[6,-33,[2,"37ftPtL8lFq63vCWNsz1Y4"],[12],[4],13]],[0,"6bsN/LSq5A3Jts7PFOohsj",1,0],[1,0,0.00009999999747378752,0],[1,1,0.5,1]],[33,"Road_L",3,[[6,-34,[2,"74Mm8XzNNGvoMjJ0UCn+DX"],[14],[4],15]],[0,"b77l7K8C5CwYOllxzxgFTN",1,0],[1,0,0.00009999999747378752,0],[3,0,-0.00006265379476170804,0,0.9999999980372511],[1,1,0.5,1],[1,0,-0.00717959602534672,0]],[22,"Road_T",3,[[6,-35,[2,"beaf4NnbtHkJEAp10K40EZ"],[16],[4],17]],[0,"a61qtPW6hLZ7i7UJhpM7Xx",1,0],[1,0,0.00009999999747378752,0],[1,1,0.5,1]],[22,"Road_X",3,[[6,-36,[2,"37BT/crMBPRYAHYCp+krHB"],[18],[4],19]],[0,"54cHG5q/NAIbf/1esZL6yJ",1,0],[1,0,0.00009999999747378752,0],[1,1,0.5,1]],[22,"Border",6,[[6,-37,[2,"5ez8oVtupPrLo3PN+sQeop"],[20],[4],21]],[0,"27EqORGKtE7pATFo+xT7/r",1,0],[1,0,0,0.00033000000985339284],[1,1.25,1.25,1]]],0,[0,3,1,0,0,1,0,0,1,0,-1,2,0,-1,4,0,1,2,0,-3,8,0,-4,6,0,1,2,0,-1,13,0,-2,14,0,-3,15,0,-4,16,0,-5,17,0,1,4,0,-2,5,0,-1,7,0,-2,11,0,-3,12,0,0,6,0,-1,18,0,1,6,0,0,7,0,-1,10,0,1,8,0,-2,9,0,1,9,0,1,9,0,0,10,0,0,11,0,0,12,0,0,13,0,0,14,0,0,15,0,0,16,0,0,17,0,0,18,0,5,1,3,1,4,37],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,-1,2,-1,2,-1,-2,-3,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,7],[12,43,13,44,14,45,13,14,12,46,3,47,3,48,3,49,3,50,3,51,52,53,54,55,2]],[[[9,"player"],[53,"player",2,[-8],[[[120,-5,[2,"3fL7tVeghAs6okoV6aB0nK"],-4,-3,-2],-6,-7],4,1,1],[0,"798l8wdO9On5EuqNRUB9Oo",-1,0],[1,2,0.19,3]],[85,"Stickman_heads_sphere",2,1,[-10,-11],[-9],[0,"1aiRiLpVJOrZC4vIYGwKlb",1,0],[3,0,-0.70710676908493,0,0.7071067932881648],[1,0,-89.99999803884896,0]],[30,"pelvis",2,[-12,-13,-14],[0,"c0rbYR8JhK0IarYhiZUURP",1,0],[1,0.0003530216054059565,0.5320438146591187,-0.010404620319604874],[3,0.000938245192798024,0.7071074700741742,0.0009381609081067217,0.707104847469857],[1,0.000006547519907902562,90.00021249711088,0.15204235717723355]],[30,"spine_03",2,[-15,-16,-17],[0,"e2pSRY8h9EuL4SLeCALXmY",1,0],[1,1.9732389056059674e-9,0.11913514882326126,-2.084243888589299e-11],[3,-0.0005527358210240716,0.000014614251237330086,0.019595084915175535,0.9998078449965787],[1,-0.06340821012290593,0.002917718983056647,2.2455737799618842]],[30,"hand_l",2,[-18,-19],[0,"96AqyMBW1DKpFoSdopx5dO",1,0],[1,4.284083843231201e-8,0.19866184890270233,4.330649971961975e-8],[3,-0.1913259893245287,-0.5592927844419798,0.019054326859227904,0.8063639871100823],[1,-17.232663223271103,-67.33283971812196,14.166701685863258]],[30,"hand_r",2,[-20,-21],[0,"d7l8Y4ZwNIjINtyDlpx+Xj",1,0],[1,-2.0489096641540527e-8,0.19866184890270233,3.259629011154175e-8],[3,-0.1913251247384335,0.5592929027194505,-0.019054548482251094,0.8063641049759169],[1,-17.23256153789166,67.33286123332685,-14.166668597063124]],[72,"Stickman_heads_sphere",2,2,[[119,0,-22,[2,"f8y12LS8FNIrlFOVyDMmcz"],[0],[4],2,1,2]],[0,"26W8a4Hd5ILK/coDXpmJ63",1,0],[3,6.123234262925839e-17,1,6.123234262925839e-17,3.7493993930529855e-33],[1,-7.0167096047110005e-15,-180,7.0167096047110005e-15]],[49,"Skelet.c",2,2,[-23],[0,"9bvB5R8DtLkrT5KRtnXq9k",1,0],[3,-0.7071067215818986,3.090861663997002e-8,-3.09086237453975e-8,0.7071068407911901],[1,-89.9999903406537,-1.5351845413740977e-13,-0.000005008956312487746]],[49,"root",2,8,[3],[0,"443Xzf/TFO2oQd2qPc3cWv",1,0],[3,0.7071068407896928,-0.000001455469739434805,-0.000001455469398374286,0.7071067215804012],[1,90.00000965934632,-7.753346216819752e-12,-0.00023586894010005214]],[13,"spine_01",2,3,[-24],[0,"94lW4BVVdM8JVxESCSJhux",1,0],[1,-0.004331294912844896,0.07350046932697296,1.3029043399725992e-9],[3,1.0946637331541135e-8,-1.051213512125179e-8,0.04456724581582408,0.9990063866664676],[1,0.0000013120437142162198,-0.0000012643323844857656,5.108722323184987]],[13,"spine_02",2,10,[4],[0,"25MvtNrfNIkKWkLFDj6QIz",1,0],[1,0.019369743764400482,0.13551770150661469,-5.630812260903895e-9],[3,-3.3986080420356614e-8,-1.8928189179573522e-8,-0.07922262859740593,0.9968569481716602],[1,-0.000004105647938027835,-0.000002502135270211383,-9.087767625861655]],[13,"clavicle_l",2,4,[-25],[0,"72b8TAljlIkKHEy37QGSmj",1,0],[1,-0.015249783173203468,0.31068751215934753,0.01920408010482788],[3,0.7585752595210817,0.1284185795083252,-0.14661160089817354,0.6217533936872901],[1,101.17918472442217,22.466995717382073,0.7172354816536206]],[13,"upperarm_l",2,12,[-26],[0,"1fMmV62lBMUpWJTQ4QLVLs",1,0],[1,2.7939677238464355e-9,0.1396692395210266,-6.51925802230835e-9],[3,0.21380619586668112,0.059386342435993084,0.1648129066665299,0.9610394782407343],[1,24.615091314252783,2.6637595113666532,20.009610369179782]],[13,"lowerarm_l",2,13,[5],[0,"e2x77on5pP+ZmVUSzdaywS",1,0],[1,3.725290298461914e-9,0.26387739181518555,1.5087425708770752e-7],[3,0.08541884987519217,-0.10010077023140458,0.2310170373923381,0.9640096391216978],[1,13.49933867152886,-14.907122727126435,25.35999584338928]],[18,"index_01_l",2,5,[[16,"index_02_l",2,-27,[0,"0bPlcpdwlJWI/IuED1xcik",1,0],[1,3.166496753692627e-8,0.05361089110374451,4.842877388000488e-8],[3,0.10384132745600216,0.01118666775302738,-0.25023230988668327,0.9625360399826771],[1,13.542216467723723,4.804474864852943,-28.645697258656362]]],[0,"45f9kXYp1JpIBo4eXYJhWu",1,0],[1,0.012653877027332783,0.062184080481529236,-0.004037775099277496],[3,0.05375861150786414,0.18280420206457337,-0.109233643117032,0.9755822090463017],[1,8.488907336687232,22.05652890382414,-11.155837825617352]],[18,"thumb_01_l",2,5,[[16,"thumb_02_l",2,-28,[0,"f3HNN4cYdPk5GyorLoV64M",1,0],[1,-5.587935447692871e-7,0.028589412569999695,-2.7939677238464355e-8],[3,0.1221369380461655,0.14330084909884125,-0.16966328365820074,0.9673478201715117],[1,17.33903761962359,19.471756928808784,-17.052159565010502]]],[0,"e2iCwMx8NOS7ZScqe8JepD",1,0],[1,0.013693361543118954,0.03710309788584709,0.053495854139328],[3,0.48533847647419237,0.5553387371377874,0.10012528987449876,0.6678475698956049],[1,46.54524462239025,60.60344930383616,42.28287185663701]],[13,"clavicle_r",2,4,[-29],[0,"854wcHBFZPqbKIlEIHa7yF",1,0],[1,-0.015247837640345097,0.3107299506664276,-0.019225364550948143],[3,-0.1467915644126778,-0.6225846493548879,0.7578804594901887,-0.12828795784433644],[1,101.06217958612535,157.52581149194737,-0.6688588236483445]],[13,"upperarm_r",2,17,[-30],[0,"9eD+qUjqlNk49Y4lXTktER",1,0],[1,-5.587935447692871e-9,0.13966920971870422,6.05359673500061e-9],[3,0.21380619643428858,-0.059386297890167035,-0.16481290710407118,0.9610394807920785],[1,24.61509226596958,-2.6637542626492836,-20.009609314348115]],[13,"lowerarm_r",2,18,[6],[0,"13Y7TOWdxBx76Lz5Ra3iGt",1,0],[1,-1.862645149230957e-9,0.2638774812221527,-1.1641532182693481e-9],[3,0.08541834503337176,0.10010085429444764,-0.23101635680074403,0.9640098382235488],[1,13.499262890161257,14.90710397472364,-25.359923973239773]],[18,"index_01_r",2,6,[[16,"index_02_r",2,-31,[0,"9ax1ewaKdEp5+ogIMxBwiK",1,0],[1,-1.4901161193847656e-8,0.053610909730196,-4.842877388000488e-8],[3,0.1038411940374416,-0.01118685502340313,0.25023210293771453,0.9625361060006699],[1,13.542202676787952,-4.804490187762133,28.645671061681373]]],[0,"6dWfvSl4NNxYX16EX35RYB",1,0],[1,-0.012653809040784836,0.06218409910798073,-0.004037774167954922],[3,0.05375876595353191,-0.18280416540513766,0.10923342295276645,0.9755822320561739],[1,8.488919230469095,-22.056523335206258,11.155809964799012]],[18,"thumb_01_r",2,6,[[16,"thumb_02_r",2,-32,[0,"cep+vN9f9FeadqTjBi5TXU",1,0],[1,6.034970283508301e-7,0.02858944982290268,-2.7939677238464355e-8],[3,0.12213705151709808,-0.1433010509823956,0.1696632905880798,0.9673477747226565],[1,17.33905464996592,-19.47178293880197,17.05215453980309]]],[0,"b51vrq5SBMzKRgUCSnz7DN",1,0],[1,-0.013693323358893394,0.03710305690765381,0.0534958653151989],[3,0.4853378864523561,-0.5553386248220414,-0.10012553698653778,0.6678480550229081],[1,46.545155475613214,-60.60344930047373,-42.282845747655394]],[18,"neck_01",2,4,[[16,"head",2,-33,[0,"f96r8aIqRLtL9JSV1M/GvE",1,0],[1,0.0018450785428285599,0.07722138613462448,-3.212807797581263e-11],[3,1.307798659220679e-8,1.7502537594571004e-7,-0.07571666629030933,0.9971293729731621],[1,0.000003047877995634063,0.000020345610519282447,-8.684802702391597]]],[0,"a8wt7QVfVND5zjuNZJ+l11",1,0],[1,-0.00002404675069556106,0.33257636427879333,0.00001432070985174505],[3,0.0005479554532572181,-0.00007392619595385615,0.08818183099526028,0.9961042410119848],[1,0.06429337426889734,-0.014196126356094081,10.11802924153785]],[13,"thigh_l",2,3,[-34],[0,"a9o39RrAFIs78Qwj7Z/2AI",1,0],[1,-0.0019309008494019508,0.060946110635995865,0.10094382613897324],[3,0.9891818493566049,-0.10959382058002042,-0.06462320510132841,0.07302263181064483],[1,172.31252245684405,6.593244657754153,-13.0766493723749]],[18,"calf_l",2,23,[[16,"foot_l",2,-35,[0,"a5dUkMVtVN7I+cRQgA4EmK",1,0],[1,0.00006084551569074392,0.29228517413139343,-0.00028398275026120245],[3,0.7823355397381153,-0.6219819346706755,-0.03257073917585142,0.005359398803419615],[1,-171.91605627859073,11.178270494156601,-76.79181311103764]]],[0,"44h0KjJWdAaY9qROzknIU/",1,0],[1,9.313225746154785e-9,0.3119881749153137,-2.7939677238464355e-9],[3,0.03465793283187069,0.052570458522714136,-0.22374995061810693,0.9726104740238654],[1,5.7861597045155095,7.50175547328921,-25.569087461636848]],[73,"thigh_r",2,3,[-36],[0,"1fUwQXO0NJXY73PccQuXMh",1,0],[1,-0.0019309690687805414,0.06094609573483467,-0.1016499325633049],[3,-0.06462356335475432,-0.07302261761635526,0.9891816205134767,0.10959568428602379],[1,0.9999980330467224,0.9999997615814209,0.9999986886978149],[1,172.31253826482302,173.40672523557967,13.076866270297616]],[18,"calf_r",2,25,[[16,"foot_r",2,-37,[0,"923VplIMhMx4jE1p9Mrc84",1,0],[1,-0.00006084900815039873,0.29228517413139343,-0.00028399628354236484],[3,0.7823184547213856,0.6223313664131324,0.0256584932665719,-0.0048111853005443185],[1,-170.0674035966481,-11.633198291641099,76.77413772639794]]],[0,"bcgJw3TtRDXKfb7seKqfmo",1,0],[1,-1.862645149230957e-8,0.31198829412460327,-8.381903171539307e-9],[3,0.03465776453059902,-0.05257035320860371,0.22375267324889345,0.9726098593656338],[1,5.786166889643856,-7.501765667782016,25.56940796807284]],[101,2,[2,"2bfrpH4RpGOamSvXj95Q/p"]],[94,2,400,false,1,[2,"d5NcnWKJdByZv+BgAkpNU/"],[1,1,0,1],[1,0,0,0]],[91,1,[2,"32HpQU3RVL+IqFTLiv8alW"],[1,0,0.9,0],[1,0.4,1.8,1]]],0,[0,3,1,0,23,29,0,24,28,0,25,27,0,0,1,0,-2,28,0,-3,29,0,-1,2,0,-1,27,0,-1,7,0,-2,8,0,-1,10,0,-2,23,0,-3,25,0,-1,12,0,-2,17,0,-3,22,0,-1,15,0,-2,16,0,-1,20,0,-2,21,0,0,7,0,-1,9,0,-1,11,0,-1,13,0,-1,14,0,1,15,0,1,16,0,-1,18,0,-1,19,0,1,20,0,1,21,0,1,22,0,-1,24,0,1,24,0,-1,26,0,1,26,0,5,1,3,1,9,4,1,11,5,1,14,6,1,19,37],[0,0,0,27,29],[-1,2,15,12,7],[56,10,11,6,2]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@e9a6d","back":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@40c10","left":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@8fd34","right":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@74afd","top":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@bb97f","bottom":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@7d38f"}]}],[10],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[60,"default-material",[{}],[{}]]],0,0,[0],[4],[1]],[[[121,"main"],[122,"main",[[-3,-4,-5,-6,-7,-8,[74,"GameManager","5adXaEaetF1K1faVaBsvXx",-9]],1,1,1,1,1,1,4],[87,"d506a06e-74ac-4f95-8031-3d36a5f6ce2c",[-1,-2]],[123,[124,0.5208,[2,1,1,1,0.520833125],[2,1,1,1,1],[2,0.519964,0.630786,0.905039,0.5208],[2,0.519544,0.630484,0.905069,0]],[125,true,1,[4,4283190348]],[126,true,9,10],[127],[128]]],[75,"Canvas",33554432,"e84+tpszpOp4mMCSQRbOmf",1,[-16,-17],[[54,-10,[5,750,1334]],[129,-12,-11],[130,45,5.684341886080802e-14,5.684341886080802e-14,-1.1368683772161603e-13,-1.1368683772161603e-13,-13],[132,-14],[133,-15]],[1,375.00000000000006,666.9999999999999,0]],[1,["c46/YsCPVOJYA4mWEpNYRx"]],[14,0,{},1,[19,"798l8wdO9On5EuqNRUB9Oo",-20,[98,"f4zWTlKkBF0b5DUGZ2o3AT",null,[[3,"player",["_name"],[1,["798l8wdO9On5EuqNRUB9Oo"]]],[8,["_lpos"],[1,["798l8wdO9On5EuqNRUB9Oo"]],[1,1,0,1]],[8,["_lscale"],[1,["798l8wdO9On5EuqNRUB9Oo"]],[1,1,1,1]],[8,["_lrot"],[1,["798l8wdO9On5EuqNRUB9Oo"]],[3,0,0,0,1]],[8,["_euler"],[1,["798l8wdO9On5EuqNRUB9Oo"]],[1,0,0,0]],[8,["_lscale"],[1,["1aiRiLpVJOrZC4vIYGwKlb"]],[1,0.5,0.5,0.5]],[7,["_size"],-18,[1,0.2,0.9,0.5]],[7,["_center"],-19,[1,0,0.45,0]]]],0]],[76,"Screen",33554432,2,[-23],[[54,-21,[5,750,1334]],[131,45,100,100,-22]]],[50,"3D-Camera","c9DMICJLFO5IeO07EPon7U",1,[[134,1,6,1073741887,-24,[4,4294617600]],[59,-25,4,[1,-8,7,0]]],[1,-8,7,0],[3,-0.24184476264797528,-0.6644630243886747,-0.24184476264797522,0.6644630243886748],[1,-40,-90,0]],[50,"3D-UI-Camera","46CJE/4qhKj4/bwrCdj6Qi",1,[[135,8388608,-26,[4,4294617600]],[59,-27,4,[1,-8,7,0]]],[1,-8,7,0],[3,-0.24184476264797528,-0.6644630243886747,-0.24184476264797522,0.6644630243886748],[1,-40,-90,0]],[14,0,{},5,[19,"c46/YsCPVOJYA4mWEpNYRx",-28,[97,"6eCUSdGmVNNbhW8RhS+TtQ",[[20,"StartScreen",["_name"],3],[7,["_lpos"],3,[1,0,0,0]],[7,["_lscale"],3,[1,1,1,1]],[7,["_lrot"],3,[3,0,0,0,1]],[7,["_euler"],3,[1,0,0,0]],[20,false,["_active"],3]]],1]],[77,"Main Light","c0y6F5f+pAvI805TdmxIjx",1,[[137,true,-29,[138]]],[3,-0.8005972817813567,-0.1453229557254247,-0.33176781330654553,0.4773419623260901],[1,-120.254,-42.248,-4.821]],[1,["32HpQU3RVL+IqFTLiv8alW"]],[83,"Camera",2,[-30],[1,0,0,1000]],[136,0,1073741824,667,2000,6,41943040,11,[4,4278190080]],[78,"MapManager","caMzImHBNIe7reo9om72jG",1,[[139,-31,2,3,4,5,6,7,8]]]],0,[0,-1,4,0,-2,8,0,-1,9,0,-2,6,0,-3,7,0,-4,4,0,-5,2,0,-6,13,0,1,1,0,0,2,0,26,12,0,0,2,0,0,2,0,0,2,0,0,2,0,-1,11,0,-2,5,0,6,10,0,6,10,0,3,4,0,0,5,0,0,5,0,-1,8,0,0,6,0,0,6,0,0,7,0,0,7,0,3,8,0,0,9,0,-1,12,0,0,13,0,27,1,31],[0,0,0,0,0,0,0,0,0,0,0],[8,8,28,29,30,31,32,33,34,35,36],[57,58,59,60,61,62,63,64,65,66,67]],[[[9,"field"],[43,"field",32,[-8,-9,-10],[[92,true,-2,[2,"87/XDxaTNLJI5LoJLEQuLT"],[1,1,0,1],[1,2.5,1,2.5],0],[140,-6,[2,"64/JLe3QNPeqCxZ1uPsgAw"],-5,-4,-3,1,2,3],[24,2,-7,[2,"61OEJLc6NNMKCMBGvjwJt0"]]],[0,"5fe4fagvBDyJKIOuT7Pnte",-1,0]],[35,"fieldCellContainer",32,1,[0,"d33hstCxFEE6GPrwB81RQ7",1,0]],[35,"cornContainer",32,1,[0,"7enwyZsVdNYot1DWESKPj4",1,0]],[35,"tomatoContainer",32,1,[0,"59YlEEjUhDDYQp41d/e4Dx",1,0]]],0,[0,3,1,0,0,1,0,37,4,0,38,3,0,39,2,0,0,1,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,5,1,10],[0,0,0,0],[7,40,41,42],[2,68,69,70]],[[[5,".bin",4286924565,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":7680,"length":2688,"count":672,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":13872,"length":1200,"count":300,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":20448,"length":2016,"count":504,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":7680,"count":160,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":10368,"length":3504,"count":73,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":15072,"length":5376,"count":112,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.039000000804662704,-0.09000001847743988,-0.0390000119805336],"maxPosition",8,[1,0.039000000804662704,2.38418573772492e-9,0.039000000804662704]]],-1],0,0,[],[],[]],[[[5,".bin",944322892,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.004999999888241291,-0.004999999888241291,-3.0616167178726134e-19],"maxPosition",8,[1,0.004999999888241291,0.004999999888241291,3.0616167178726134e-19]]],-1],0,0,[],[],[]],[[[23,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":0},"mainColor",8,[4,4278255431],"emissive",8,[4,4278242824],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[9,4],[71,1]],[[[10,"MiniMapCell",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":20},"mainColor",8,[4,4281204480],"specularColor",8,[4,4281545523],"emissiveColor",8,[4,4278190080]]],11]]],0,0,[0],[4],[0]],[[[5,".bin",2428542867,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":960,"length":312,"count":78,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":960,"count":24,"stride":40},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005999999586492777,0,-0.029999999329447746],"maxPosition",8,[1,0.005999999586492777,0,-0.02500000037252903]]],-1],0,0,[],[],[]],[[[5,".bin",3240824443,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":320,"length":72,"count":18,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":320,"count":8,"stride":40},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005999999586492777,0,-0.029999999329447746],"maxPosition",8,[1,0.005999999586492777,0,0.029999999329447746]]],-1],0,0,[],[],[]],[[[5,".bin",1057882522,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.004999999888241291,-0.004999999888241291,-0.004999999888241291],"maxPosition",8,[1,0.004999999888241291,0.004999999888241291,0.004999999888241291]]],-1],0,0,[],[],[]],[[[10,"Road",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true,"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":20},"mainColor",8,[4,4284847078],"specularColor",8,[4,4281545523],"emissiveColor",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[9,4],[72,0]],[[[5,".bin",1057882522,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.004999999888241291,-0.004999999888241291,-0.004999999888241291],"maxPosition",8,[1,0.004999999888241291,0.004999999888241291,0.004999999888241291]]],-1],0,0,[],[],[]],[[[10,"MiniMapBeach",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":20},"mainColor",8,[4,4294967295],"specularColor",8,[4,4281545523],"emissiveColor",8,[4,4278190080]]],11]]],0,0,[0],[4],[0]],[[[23,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"metallic":0},"mainColor",8,[4,4283462603]],{},{}],11,0,0]]],0,0,[0],[4],[1]],[[[5,".bin",2657912715,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2080,"length":840,"count":210,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2080,"count":52,"stride":40},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.029999999329447746,-8.061530110126114e-9,-0.029999999329447746],"maxPosition",8,[1,0.029999999329447746,2.369376028710235e-9,0.029999999329447746]]],-1],0,0,[],[],[]],[[[5,".bin",1999789117,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":960,"length":360,"count":90,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":960,"count":24,"stride":40},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005999999586492777,0,-0.006000001449137926],"maxPosition",8,[1,0.029999999329447746,0,0.029999999329447746]]],-1],0,0,[],[],[]],[[[5,".bin",2473722658,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1680,"length":672,"count":168,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1680,"count":42,"stride":40},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005999999586492777,0,-0.029999999329447746],"maxPosition",8,[1,0.029999999329447746,0,0.029999999329447746]]],-1],0,0,[],[],[]],[[[5,".bin",944322892,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.004999999888241291,-0.004999999888241291,-3.0616167178726134e-19],"maxPosition",8,[1,0.004999999888241291,0.004999999888241291,3.0616167178726134e-19]]],-1],0,0,[],[],[]],[[[5,".bin",1057882522,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.004999999888241291,-0.004999999888241291,-0.004999999888241291],"maxPosition",8,[1,0.004999999888241291,0.004999999888241291,0.004999999888241291]]],-1],0,0,[],[],[]],[[[23,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{"metallic":0},"mainColor",8,[4,4278248161]],{},{}],11,0,0]]],0,0,[0],[4],[1]],[[[5,".bin",3908795170,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.004999999888241291,-3.7748951187133173e-10,-0.004999999888241291],"maxPosition",8,[1,0.004999999888241291,3.7748951187133173e-10,0.004999999888241291]]],-1],0,0,[],[],[]],[[[10,"Field 1",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_NORMAL_MAP":true,"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":20},"mainColor",8,[4,4280772863],"specularColor",8,[4,4281545523],"emissiveColor",8,[4,4278190080],"normalMap",6,0]],11]]],0,0,[0,0],[43,4],[73,0]],[[[61,"StickMan",[{},{},{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_BATCHING":true},{},{}]]],0,0,[0],[4],[1]],[[[141,"dcc/imported-specular-glossiness",[{"hash":2269931406,"name":"dcc/imported-specular-glossiness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_NORMAL_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":10,"defines":["CC_FORWARD_ADD"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":11,"defines":["CC_FORWARD_ADD"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_debug_view_mode;\n  mediump vec4 cc_debug_view_composite_pack_1;\n  mediump vec4 cc_debug_view_composite_pack_2;\n  mediump vec4 cc_debug_view_composite_pack_3;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      return CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    float realtimeShadow = 1.0;\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    }else {\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    }\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && layer < 0) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          layer = i;\n        }\n      }\n      return layer;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      vec4 csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      if (level < 0) { return 1.0; }\n      float realtimeShadow = 1.0;\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      float pcf = cc_shadowWHPBInfo.z;\n      if (pcf > 1.9) {\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      } else if (pcf > 0.9) {\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      }else {\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      }\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n      vec4 shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(shadowPos, N, shadowBias);\n    }\n  #endif\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      if (cc_shadowLPNNInfo.w > 0.0) {\n        shadow = CCCSMFactorBase(position, N, s.shadowBias);\n      } else {\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      }\n    }\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec3 finalColor = diffuse * s.lightmap.rgb * shadow;\n  #else\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * (cc_ambientGround.w - 1.0));\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = LinearToSRGB(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#define DCC_APP_OTHERS 0\n#define DCC_APP_AUTODESK 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_AUTODESK\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_AUTODESK\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, specularFactor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = vec4(1.0);\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    texColor.a *= transparencyFactor;\n    baseColor *= texColor;\n  #else\n    baseColor *= diffuseColor;\n  #endif\n  baseColor.rgb *= diffuseFactor;\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture(transparencyMap, TEXTURE_UV).a;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < alphaThreshold) discard;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  vec4 specularColorAndFactor = getSpecularColorAndFactor();\n  float inGlossiness = 0.0, inSpecularIntensity = specularColorAndFactor.w;\n  #if HAS_EXPORTED_GLOSSINESS\n    #if USE_SPECULAR_GLOSSINESS_MAP\n      inGlossiness = 1.0 - texture(specularGlossinessMap, TEXTURE_UV).a;\n    #else\n      inGlossiness = glossiness;\n    #endif\n  #else\n    #if USE_SHININESS_MAP\n      #if USE_SHININESS_MAP_CHANNEL\n        inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).SHININESS_MAP_CHANNEL;\n      #else\n        inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n      #endif\n    #else\n      inGlossiness = convertShininessExponent(shininessExponent);\n    #endif\n    inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n  #endif\n  float inMetallic = 0.0;\n  vec4 albedo = baseColor;\n  #if HAS_EXPORTED_METALLIC\n    inMetallic = metallic;\n    float spec = specularFactor;\n    #if USE_SPECULAR_MAP\n      spec = dot(GRAY_VECTOR, texture(specularMap, TEXTURE_UV).rgb);\n    #endif\n    inSpecularIntensity *= spec * 0.5;\n  #else\n    GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n    inSpecularIntensity *= inMetallic;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalScale) * normalize(v_tangent) +\n      (nmmp.y * normalScale) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    packHighpData(s.position, s.position_fract_part, v_position);\n    #else\n    s.position = v_position;\n    #endif\n  s.albedo = albedo;\n  s.occlusion = 1.0;\n  s.roughness = 1.0 - inGlossiness;\n  s.metallic = inMetallic;\n  s.specularIntensity = inSpecularIntensity * 0.5;\n  s.emissive = vec3(0.0);\n#if USE_EMISSIVE_MAP\n  s.emissive = texture(emissiveMap, TEXTURE_UV).xyz;\n#endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_debug_view_mode;\n  uniform mediump vec4 cc_debug_view_composite_pack_1;\n  uniform mediump vec4 cc_debug_view_composite_pack_2;\n  uniform mediump vec4 cc_debug_view_composite_pack_3;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 diffuseColor;\n     uniform vec4 specularColor;\n     uniform vec4 emissive;\n     uniform float alphaThreshold;\n     uniform float shininessExponent;\n     uniform float glossiness;\n     uniform float metallic;\n     uniform float normalScale;\n     uniform float transparencyFactor;\n     uniform float diffuseFactor;\n     uniform float specularFactor;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (cc_debug_view_mode.y > 0.0)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (cc_debug_view_mode.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (cc_debug_view_composite_pack_1.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (cc_debug_view_composite_pack_1.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (cc_debug_view_composite_pack_1.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (cc_debug_view_composite_pack_1.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (cc_debug_view_composite_pack_2.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (cc_debug_view_composite_pack_2.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (cc_debug_view_composite_pack_2.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (cc_debug_view_composite_pack_2.w > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (cc_debug_view_composite_pack_3.x > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (cc_debug_view_composite_pack_3.y > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (cc_debug_view_composite_pack_3.z > 0.0)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (cc_debug_view_composite_pack_3.w > 0.0)\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      return CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    float realtimeShadow = 1.0;\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    }else {\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    }\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      int layer = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= (0.0 + layerThreshold) && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= (0.0 + layerThreshold) && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && layer < 0) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          layer = i;\n        }\n      }\n      return layer;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      vec4 csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      if (level < 0) { return 1.0; }\n      float realtimeShadow = 1.0;\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      float pcf = cc_shadowWHPBInfo.z;\n      if (pcf > 1.9) {\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      } else if (pcf > 0.9) {\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      }else {\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      }\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n      vec4 shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(shadowPos, N, shadowBias);\n    }\n  #endif\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      if (cc_shadowLPNNInfo.w > 0.0) {\n        shadow = CCCSMFactorBase(position, N, s.shadowBias);\n      } else {\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      }\n    }\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec3 finalColor = diffuse * s.lightmap.rgb * shadow;\n  #else\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * (cc_ambientGround.w - 1.0));\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = LinearToSRGB(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#define DCC_APP_OTHERS 0\n#define DCC_APP_AUTODESK 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_AUTODESK\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_AUTODESK\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture2D(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture2D(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, specularFactor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = vec4(1.0);\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    texColor.a *= transparencyFactor;\n    baseColor *= texColor;\n  #else\n    baseColor *= diffuseColor;\n  #endif\n  baseColor.rgb *= diffuseFactor;\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture2D(transparencyMap, TEXTURE_UV).a;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < alphaThreshold) discard;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  vec4 specularColorAndFactor = getSpecularColorAndFactor();\n  float inGlossiness = 0.0, inSpecularIntensity = specularColorAndFactor.w;\n  #if HAS_EXPORTED_GLOSSINESS\n    #if USE_SPECULAR_GLOSSINESS_MAP\n      inGlossiness = 1.0 - texture2D(specularGlossinessMap, TEXTURE_UV).a;\n    #else\n      inGlossiness = glossiness;\n    #endif\n  #else\n    #if USE_SHININESS_MAP\n      #if USE_SHININESS_MAP_CHANNEL\n        inGlossiness = 1.0 - texture2D(shininessExponentMap, TEXTURE_UV).SHININESS_MAP_CHANNEL;\n      #else\n        inGlossiness = 1.0 - discolor(texture2D(shininessExponentMap, TEXTURE_UV).rgb);\n      #endif\n    #else\n      inGlossiness = convertShininessExponent(shininessExponent);\n    #endif\n    inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n  #endif\n  float inMetallic = 0.0;\n  vec4 albedo = baseColor;\n  #if HAS_EXPORTED_METALLIC\n    inMetallic = metallic;\n    float spec = specularFactor;\n    #if USE_SPECULAR_MAP\n      spec = dot(GRAY_VECTOR, texture2D(specularMap, TEXTURE_UV).rgb);\n    #endif\n    inSpecularIntensity *= spec * 0.5;\n  #else\n    GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n    inSpecularIntensity *= inMetallic;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalScale) * normalize(v_tangent) +\n      (nmmp.y * normalScale) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    packHighpData(s.position, s.position_fract_part, v_position);\n    #else\n    s.position = v_position;\n    #endif\n  s.albedo = albedo;\n  s.occlusion = 1.0;\n  s.roughness = 1.0 - inGlossiness;\n  s.metallic = inMetallic;\n  s.specularIntensity = inSpecularIntensity * 0.5;\n  s.emissive = vec3(0.0);\n#if USE_EMISSIVE_MAP\n  s.emissive = texture2D(emissiveMap, TEXTURE_UV).xyz;\n#endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":181,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":113}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"USE_BATCHING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,4]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"SHININESS_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"HAS_EXPORTED_GLOSSINESS","type":"boolean"},{"name":"USE_SHININESS_MAP_CHANNEL","type":"boolean"},{"name":"HAS_EXPORTED_METALLIC","type":"boolean"},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"}]},{"hash":2706003509,"name":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TRANSPARENCY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]},{"name":"a_color","format":44,"location":15,"defines":["USE_VERTEX_COLOR"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout highp vec2 v_clip_depth;\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n    mediump vec4 cc_debug_view_mode;\n    mediump vec4 cc_debug_view_composite_pack_1;\n    mediump vec4 cc_debug_view_composite_pack_2;\n    mediump vec4 cc_debug_view_composite_pack_3;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_surfaceTransform;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin highp vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  #if USE_ALPHA_TEST\n    float alpha = diffuseColor.a;\n    #if USE_VERTEX_COLOR\n      alpha *= v_color.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha *= texture(albedoMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_TRANSPARENCY_MAP\n      alpha = texture(transparencyMap, TEXTURE_UV).a;\n    #endif\n    if (alpha < alphaThreshold) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 diffuseColor;\n   uniform float alphaThreshold;\n   uniform float transparencyFactor;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  #if USE_ALPHA_TEST\n    float alpha = diffuseColor.a;\n    #if USE_VERTEX_COLOR\n      alpha *= v_color.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha *= texture2D(albedoMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_TRANSPARENCY_MAP\n      alpha = texture2D(transparencyMap, TEXTURE_UV).a;\n    #endif\n    if (alpha < alphaThreshold) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":96,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":113}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"USE_BATCHING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]]]]
